<!DOCTYPE html>

<html lang="en">

<head>
	<title>Tutorial: Extending Thymeleaf</title>
	<meta charset="utf-8">
	<meta name="generator" content="pandoc">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<meta name="format-detection" content="telephone=no"/>

	<link rel="icon" href="../../images/favicon.ico"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,400italic,700,700italic"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/2.1.3/normalize.min.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-screen.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-print.css" media="print"/>

	<script src="https://unpkg.com/dumb-query-selector@3.0.0/dumb-query-selector.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-core.min.js" defer data-manual></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-markup.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-java.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/line-numbers/prism-line-numbers.min.js" defer></script>
	<script src="../../scripts/thymeleaf-tutorials.js" defer></script>

</head>

<body class="tutorial">

	<div class="toc-wrapper toolbar-container">
		<div class="toolbar-menu">
			<div id="toolbar-location" class="toolbar-menu-location"></div>
			<button id="site-menu-button" type="button" class="toolbar-menu-button">Doc Contents</button>
		</div>
		<nav id="toc">
			<ul>
<li><a href="#some-reasons-to-extend-thymeleaf">1 Some Reasons to Extend Thymeleaf</a><ul>
<li><a href="#scenario-1-adding-features-to-the-standard-dialects">1.1. Scenario 1: adding features to the Standard dialects</a></li>
<li><a href="#scenario-2-view-layer-components">1.2. Scenario 2: view-layer components</a></li>
<li><a href="#scenario-3-creating-your-own-template-system">1.3. Scenario 3: creating your own template system</a></li>
</ul></li>
<li><a href="#dialects-and-processors">2 Dialects and Processors</a><ul>
<li><a href="#dialects">2.1. Dialects</a></li>
<li><a href="#processors">2.2. Processors</a><ul>
<li><a href="#special-kinds-of-processors">Special kinds of processors</a><ul>
<li><a href="#attribute-processors">Attribute Processors</a></li>
<li><a href="#element-processors">Element Processors</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#template-modes">3 Template Modes</a></li>
<li><a href="#creating-our-own-dialect">4 Creating our own Dialect</a><ul>
<li><a href="#extrathyme-a-website-for-thymelands-football-league">4.1. Extrathyme: a website for Thymeland’s football league</a></li>
<li><a href="#changing-the-css-class-by-team-position">4.2. Changing the CSS class by team position</a></li>
<li><a href="#displaying-an-internationalized-remark">4.3. Displaying an internationalized remark</a></li>
<li><a href="#an-element-processor-for-our-headlines">4.4. An element processor for our headlines</a></li>
<li><a href="#declaring-it-all-the-dialect">4.5. Declaring it all: the Dialect</a></li>
</ul></li>
</ul>
		</nav>
	</div>

	<div class="content-wrapper">

		<div class="title-container">
			<header class="hero-header fluid-block">
				<div class="hero-header-text">
					<h1 class="hero-header-title">Thymeleaf</h1>
				</div>
				<div class="hero-header-image">
					<img src="../../images/thymeleaf.png" alt="Thymeleaf logo" class="hero-header-logo"/>
				</div>
			</header>

			<div class="tutorial-info fluid-block">
				<h1 id="tutorial-title" class="tutorial-title">Tutorial: Extending Thymeleaf</h1>
								<div class="tutorial-metadata">
					<div id="tutorial-version">
						<span class="tutorial-metadata-label">Document version:</span> 20180605 - 05 June 2018
					</div>
					<div id="project-version">
						<span class="tutorial-metadata-label">Project version:</span> 3.0.9.RELEASE
					</div>
					<div id="project-website">
						<span class="tutorial-metadata-label">Project web site:</span>
						<a href="https://www.thymeleaf.org">https://www.thymeleaf.org</a>
					</div>
				</div>
			</div>
		</div>

		<div id="content" class="fluid-block">
			<section id="some-reasons-to-extend-thymeleaf" class="level1">
<h1>1 Some Reasons to Extend Thymeleaf</h1>
<p>Thymeleaf is an extremely extensible library. The key to it is that most of its user-oriented features are not directly built into its core, but rather just packaged and componentized into feature sets called <em>dialects</em>.</p>
<p>The library offers you two dialects out-of-the-box: the <em>Standard</em> and the <em>SpringStandard</em> dialects, but you can easily create your own. Let’s explore some of the reasons for doing this:</p>
<section id="scenario-1-adding-features-to-the-standard-dialects" class="level2">
<h2>1.1. Scenario 1: adding features to the Standard dialects</h2>
<p>Say your application uses the <em>SpringStandard</em> dialect and that it needs to show an alert text box in blue or red background depending on the user’s role (admin or non-admin) from Monday to Saturday, but always in green on Sundays. You can compute this with conditional expressions on your template, but too many conditions could render your code a little bit hard to read…</p>
<p>Solution: create a new attribute called <code>alertclass</code> and an attribute processor for it (Java code that will compute the right CSS class), and package it into your own <code>MyOwnDialect</code> dialect. Add this dialect to your template engine with the <code>th</code> prefix (same as the <em>SpringStandard</em> one) and you’ll now be able to use <code>th:alertclass=&quot;${user.role}&quot;</code>!</p>
</section>
<section id="scenario-2-view-layer-components" class="level2">
<h2>1.2. Scenario 2: view-layer components</h2>
<p>Let’s say your company uses Thymeleaf extensively, and you want to create a repository of common functionalities (tags and/or attributes) that you can use in several applications without having to copy-paste them from one application to the next. This is, you want to create view-layer components in a similar way to JSPs <em>taglibs</em>.</p>
<p>Solution: create a Thymeleaf dialect for each set of related functionalities, and add these dialects to your applications as needed. Note that if the tags or attributes in these dialects make use of externalized (internationalized) messages, you will be able to package these messages along with your dialects (in the shape of <em>processor messages</em>) instead of requiring that all of your applications include them in their messages <code>.properties</code> files as you would with JSP.</p>
</section>
<section id="scenario-3-creating-your-own-template-system" class="level2">
<h2>1.3. Scenario 3: creating your own template system</h2>
<p>Now imagine your are creating a public website that allows users to create their own design templates for showing their content. Of course, you don’t want your users to be able to do absolutely anything in their templates, not even all that the Standard Dialect allows (for example, execute OGNL expressions). So you need to offer your users the ability to add to their templates only a very specific set of features that are under your control (like showing a profile photo, a blog entry text, etc).</p>
<p>Solution: create a Thymeleaf dialect with the tags or attributes you want your users to be able to use, like <code>&lt;mysite:profilePhoto /&gt;</code> or <code>&lt;mysite:blogentries fromDate=&quot;23/4/2011&quot; /&gt;</code>. Then allow your users to create their own templates using these features and just let Thymeleaf execute them, being sure nobody will be doing what they’re not allowed to.</p>
</section>
</section>
<section id="dialects-and-processors" class="level1">
<h1>2 Dialects and Processors</h1>
<section id="dialects" class="level2">
<h2>2.1. Dialects</h2>
<p>If you’ve read the <em>Using Thymeleaf</em> tutorial before getting here —which you should have done—, you should know that what you’ve been learning all this time was not exactly <em>Thymeleaf</em>, but rather its <em>Standard Dialect</em> (or the <em>SpringStandard Dialect</em>, if you’ve also read the <em>Thymeleaf + Spring</em> tutorial).</p>
<p>What does that mean? It means that all those <code>th:x</code> attributes you learned to use are only a standard, out-of-the-box set of features, but you can define your own set of attributes (or tags) with the names you wish and use them in Thymeleaf to process your templates. <em>You can define your own dialects.</em></p>
<p>Dialects are objects implementing the <code>org.thymeleaf.dialect.IDialect</code> interface, which looks like this:</p>
<pre class="java"><code>public interface IDialect {

    public String getPrefix();

    public Set&lt;IProcessor&gt; getProcessors();
    public Map&lt;String,Object&gt; getExecutionAttributes();

    public Set&lt;IDocTypeTranslation&gt; getDocTypeTranslations();
    public Set&lt;IDocTypeResolutionEntry&gt; getDocTypeResolutionEntries();
}</code></pre>
<p>Let’s see these methods step by step:</p>
<p>First, the prefix:</p>
<pre class="java"><code>    public String getPrefix();</code></pre>
<p>This is the prefix that the tags and attributes of your dialect will have, a kind of namespace (although it can be changed when adding dialects to the Template Engine). If you create an attribute named <code>earth</code> and your dialect prefix is <code>planets</code>, you will write this attribute in your templates as <code>planets:earth</code>.</p>
<p>The prefix for both the Standard and SpringStandard Dialects is, obviously, <code>th</code>. Prefix can be null so that you can define attribute/tag processors for non-namespaced tags (for example, standard <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code> or <code>&lt;table&gt;</code> tags in XHTML).</p>
<p>Now, let’s have a look at the most important part of the <code>IDialect</code> interface, the processors:</p>
<pre class="java"><code>    public Set&lt;IProcessor&gt; getProcessors();</code></pre>
<p>Processors are the objects in charge of executing on DOM nodes and performing changes on it. We will cover processors in more detail in next sections.</p>
<p><em>Execution attributes</em> are objects that are contributed by the dialect to the execution arguments during the processing of templates. These are objects —usually utility objects— that will be made available to processors during their execution. Note that these objects will not appear at the variable context, and will be only visible internally.</p>
<pre class="java"><code>    public Map&lt;String,Object&gt; getExecutionAttributes();</code></pre>
<p>More interface methods:</p>
<pre class="java"><code>    public Set&lt;IDocTypeTranslation&gt; getDocTypeTranslations();</code></pre>
<p>This returns the set of <em>DOCTYPE translations</em> to be applied. If you remember from the <em>Using Thymeleaf</em> tutorial, Thymeleaf can perform a series of DOCTYPE translations that allow you to establish a specific DOCTYPE for your templates and expect this DOCTYPE to be translated into another one in your output.</p>
<p>Last method:</p>
<pre class="java"><code>    public Set&lt;IDocTypeResolutionEntry&gt; getDocTypeResolutionEntries();</code></pre>
<p>This method returns the <em>DOCTYPE resolution entries</em> available for the dialect. DOCTYPE resolution entries allow Thymeleaf’s XML Parser to locally resolve DTDs linked from your templates (thus avoiding remote HTTP requests for retrieving these DTDs).</p>
<p>Thymeleaf makes most standard XHTML DTDs already available to your dialects by implementing the abstract class <code>org.thymeleaf.dialect.AbstractXHTMLEnabledDialect</code>, but you can always add your own ones for your own template DTDs.</p>
</section>
<section id="processors" class="level2">
<h2>2.2. Processors</h2>
<p>Processors are objects implementing the <code>org.thymeleaf.processor.IProcessor</code> interface, and they contain the real logic to be applied on DOM nodes. This interface looks like this:</p>
<pre class="java"><code>public interface IProcessor extends Comparable&lt;IProcessor&gt; {

    public IProcessorMatcher&lt;? extends Node&gt; getMatcher();

    public ProcessorResult process(final Arguments arguments,
                final ProcessorMatchingContext processorMatchingContext, final Node node);
}</code></pre>
<p>First thing we can see is that it extends <code>Comparable</code> – and that is the way <em>precedence</em> is established. If a processor is considered to be sorted <em>before</em> another one, this means it has more precedence, and therefore will be executed before the latter if they both apply to the same node.</p>
<p>Now for the methods. A processor’s <em>matcher</em> establishes when a processor is applicable to a DOM node:</p>
<pre class="java"><code>    public IProcessorMatcher&lt;? extends Node&gt; getMatcher();</code></pre>
<p>Matcher objects will examine the node’s type, name and/or attributes —if it is an <em>Element</em> DOM node— or whichever other node features required to determine processor applicability. Thymeleaf comes with a predefined set of <code>IProcessorMatcher</code> implementations so that you do not have to perform usual tasks like matching an element —tag— by its name or one of its attributes.</p>
<p>Finally, the method that does the real work:</p>
<pre class="java"><code>    public ProcessorResult process(final Arguments arguments,
                final ProcessorMatchingContext processorMatchingContext, final Node node);</code></pre>
<p><code>process(...)</code> takes three parameters:</p>
<ol type="1">
<li><p>The execution arguments. An <code>org.thymeleaf.Arguments</code> object containing context, local variables, template resolution information and some other bits of data useful for DOM processing.</p></li>
<li><p>The processor matching context, containing information about the conditions in which the processor being executed was actually matched.</p>
<blockquote>
<p>The problem is that the same processor class can be included in several dialects executing at a time in the same template engine —probably with different configurations—, but these dialects might use different prefixes. If so, how can we know the specific dialect for which the processor is being executed? That is the info this <code>ProcessorMatchingContext</code> object provides.</p>
</blockquote></li>
<li><p>The node that the processor will be executed on. Note that processors are applied on a specific node, but nothing stops them from modifying any other parts of the DOM tree.</p></li>
</ol>
<p>Thymeleaf offers an abstract utility class to be extended for creating processors: <code>org.thymeleaf.processor.AbstractProcessor</code>. This class takes care of implementing the <code>Comparable</code> interface based on the specified precedence and defines the standard mechanisms for obtaining externalized/internationalized messages:</p>
<pre class="java"><code>public abstract class AbstractProcessor implements IProcessor {

    /* Try to resolve a message first as template message, then if not */
    /* found as processor message.                                     */
    protected String getMessage(
                final Arguments arguments, final String messageKey, 
                final Object[] messageParameters) {...}

    /* Try to resolve a message as a template message */
    protected String getMessageForTemplate(
                final Arguments arguments, final String messageKey, 
                final Object[] messageParameters) {...}

    /* Try to resolve a message as a processor message */
    protected String getMessageForProcessor(
                final Arguments arguments, final String messageKey, 
                final Object[] messageParameters) {...}

    public abstract int getPrecedence();

    ...

}</code></pre>
<section id="special-kinds-of-processors" class="level3">
<h3>Special kinds of processors</h3>
<p>Although processors can execute on any node in the DOM tree, there are two specific kinds of processors that can benefit from performance improvements inside the Thymeleaf execution engine: <em>attribute processors</em> and <em>element processors</em>.</p>
<section id="attribute-processors" class="level4">
<h4>Attribute Processors</h4>
<p>Those processors (implementations of <code>IProcessor</code>) which <code>getMatcher()</code> method returns a matcher implementing the <code>org.thymeleaf.processor.IAttributeNameProcessorMatcher interface</code> are considered <em>“attribute processors”</em>.</p>
<p>Because of the type of matchers they define, these processors are triggered when a DOM element (usually an XML/XHTML/HTML5 tag) contains an attribute with a specific name. For example, most processors in the <em>Standard Dialects</em> act like this, defining matchers for attributes like <code>th:text</code>, <code>th:each</code>, <code>th:if</code>, etc.</p>
<p>For the sake of simplicity, Thymeleaf offers an utility abstract class from which attribute processors can extend: <code>org.thymeleaf.processor.attr.AbstractAttrProcessor</code>. This class already returns as matcher an implementation of IAttributeNameProcessorMatcher and makes it easier to create this kind of processors.</p>
</section>
<section id="element-processors" class="level4">
<h4>Element Processors</h4>
<p>Those processors (implementations of <code>IProcessor</code>) which <code>getMatcher()</code> method returns a matcher implementing the <code>org.thymeleaf.processor.IElementNameProcessorMatcher</code> interface are considered <em>“element processors”</em>.</p>
<blockquote>
<p>Note that the DOM jargon calls <em>“element”</em> to what we usually call <em>“tag”</em> in an XML/XHTML/HTML5 document. Thymeleaf prefers to use the word element in order to be more general, because template modes might be defined that work on documents that do not have an XML-like structure.</p>
</blockquote>
<p>Because of the type of matchers they define, these processors are triggered when a DOM element has a specific name.</p>
<p>The <em>Standard Dialects</em> define no element processors.</p>
<p>For the sake of simplicity, Thymeleaf offers an utility abstract class from which element processors can extend: <code>org.thymeleaf.processor.element.AbstractElementProcessor</code>. This class already returns as matcher an implementation of IElementNameProcessorMatcher and makes it easier to create this kind of processors.</p>
</section>
</section>
</section>
</section>
<section id="template-modes" class="level1">
<h1>3 Template Modes</h1>
<p>Probably the most powerful extension point in Thymeleaf, template modes define in fact <em>what can be considered “a template”</em>. Creating custom template modes allows us to use Thymeleaf for processing templates in formats different to the XML / XHTML / HTML5 that are available out-of-the-box.</p>
<p>Template Modes are defined by their <em>handlers</em>. These are objects implementing the <code>org.thymeleaf.templatemode.ITemplateModeHandler</code> interface:</p>
<pre class="java"><code>public interface ITemplateModeHandler {

    public String getTemplateModeName();

    public ITemplateParser getTemplateParser();

    public ITemplateWriter getTemplateWriter();

}</code></pre>
<p>Each <em>template mode handler</em> defines everything Thymeleaf needs to process templates in a specific mode: a <em>parser</em> (<code>ITemplateParser</code>) that is able to convert a template into a DOM tree, and a <em>writer</em> (<code>ITemplateWriter</code>) that is able to convert a DOM tree into the desired result format once it is processed.</p>
<p>Several template modes are provided by Thymeleaf out-of-the-box, defined at the <code>org.thymeleaf.templatemode.StandardTemplateModeHandlers</code> class, and they are preregistered for every TemplateEngine instance. Their names are:</p>
<ul>
<li><code>XML</code>: for XML that does not require validation during parsing.</li>
<li><code>VALIDXML</code>: for XML that should be validated during parsing.</li>
<li><code>XHTML</code>: for XHTML 1.0 or 1.1 templates that do not need validation.</li>
<li><code>VALIDXHTML</code>: for XHTML 1.0 or 1.1 templates that should be validated during parsing.</li>
<li><code>HTML5</code>: for HTML5 templates that are well-formed XML documents.</li>
<li><code>LEGACYHTML5</code>: for HTML5 templates that are not well-formed XML documents, and therefore need a previous preprocessing step for tag balancing, syntax correction, etc.</li>
</ul>
<p>For parsing templates in these modes, Thymeleaf offers a set of parser implementations that live at the <code>org.thymeleaf.templateparser package.</code> These parsers come in both SAX and DOM flavours —both validating and non-validating—, and there’s also a nekoHTML-based HTML parser that allows parsing code that is not well-formed XML (for example, with unclosed tags).</p>
<p>By default, all standard modes use SAX parsing, except LEGACYHTML5 which uses nekoHTML.</p>
<p>As for writers, two implementations of ITemplateWriter are provided: one for XHTML and HTML5, and another one for XML. Both live in the <code>org.thymeleaf.templatewriter</code> package.</p>
</section>
<section id="creating-our-own-dialect" class="level1">
<h1>4 Creating our own Dialect</h1>
<p>The source code for the examples shown in this and future chapters of this guide can be found in the <a href="https://github.com/thymeleaf/thymeleafexamples-extrathyme">ExtraThyme GitHub repository</a>.</p>
<section id="extrathyme-a-website-for-thymelands-football-league" class="level2">
<h2>4.1. Extrathyme: a website for Thymeland’s football league</h2>
<p>Football is a popular sport in Thymeland<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. There is a 10-team league going on there each season, and its organizers have just asked us to create a website for it called “Extrathyme”.</p>
<p>This website will be very simple: just a table with:</p>
<ul>
<li>The team names.</li>
<li>How many matches they won, drew or lost, as well as the total points earned.</li>
<li>A remark explaining whether their position in the table qualifies them for higher-level competitions next year or else mean their relegation to regional leagues.</li>
</ul>
<p>Also, above the league table, a banner will be displaying headlines with the results of recent matches.</p>
<figure>
<img src="images/extendingthymeleaf/extrathyme-league-table.png" alt="Extrathyme league table" /><figcaption>Extrathyme league table</figcaption>
</figure>
<p>We will use HTML5, Spring MVC and the SpringStandard dialect for our application, and we will be extending Thymeleaf by creating a <code>score</code> dialect that includes:</p>
<ul>
<li>A <code>score:remarkforposition</code> attribute that outputs an internationalized text for the Remarks column in the table. This text should explain whether the team’s position in the table qualifies it for the World Champions League, the Continental Play-Offs, or relegates it to the Regional League.</li>
<li>A <code>score:classforposition</code> attribute that establishes a CSS class for the table rows depending on the team’s remarks: blue background for the World Champions League, green for the Continental Play-Offs, and red for relegation.</li>
<li>A <code>score:headlines</code> tag for drawing the yellow box at the top with the results of recent matches. This tag should support an order attribute with values random (for showing a randomly selected match) and <code>latest</code> (default, for showing only the last match).</li>
</ul>
<p>Our markup will therefore look like this, making use of both <code>th</code> and <code>score</code> attributes:</p>
<pre class="html"><code>&lt;!DOCTYPE html&gt;

&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:score=&quot;http://thymeleafexamples&quot;&gt;

  &lt;head&gt;
    &lt;title&gt;extraThyme: Thymeland&#39;s football website&lt;/title&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;
          href=&quot;../../css/extrathyme.css&quot; th:href=&quot;@{/css/extrathyme.css}&quot;/&gt;
  &lt;/head&gt;

  &lt;body&gt;

    &lt;div&gt;
      &lt;img src=&quot;../../images/extrathymelogo.png&quot; 
           alt=&quot;extraThyme logo&quot; title=&quot;extraThyme logo&quot;
           th:src=&quot;@{/images/extrathymelogo.png}&quot; th:alt-title=&quot;#{title.application}&quot;/&gt;
    &lt;/div&gt;

    &lt;score:headlines order=&quot;random&quot; /&gt;

    &lt;div class=&quot;leaguetable&quot;&gt;

      &lt;h2 th:text=&quot;#{title.leaguetable(${execInfo.now.time})}&quot;&gt;
        League table for 07 July 2011
      &lt;/h2&gt;
      
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th th:text=&quot;#{team.name}&quot;&gt;Team&lt;/th&gt;
            &lt;th th:text=&quot;#{team.won}&quot; class=&quot;matches&quot;&gt;Won&lt;/th&gt;
            &lt;th th:text=&quot;#{team.drawn}&quot; class=&quot;matches&quot;&gt;Drawn&lt;/th&gt;
            &lt;th th:text=&quot;#{team.lost}&quot; class=&quot;matches&quot;&gt;Lost&lt;/th&gt;
            &lt;th th:text=&quot;#{team.points}&quot; class=&quot;points&quot;&gt;Points&lt;/th&gt;
            &lt;th th:text=&quot;#{team.remarks}&quot;&gt;Remarks&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr th:each=&quot;t : ${teams}&quot; score:classforposition=&quot;${tStat.count}&quot;&gt;
            &lt;td th:text=&quot;|${t.name} (${t.code})|&quot;&gt;The Winners (TWN)&lt;/td&gt;
            &lt;td th:text=&quot;${t.won}&quot; class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${t.drawn}&quot; class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td th:text=&quot;${t.lost}&quot; class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td th:text=&quot;${t.points}&quot; class=&quot;points&quot;&gt;3&lt;/td&gt;
            &lt;td score:remarkforposition=&quot;${tStat.count}&quot;&gt;Great winner!&lt;/td&gt;
          &lt;/tr&gt;
          &lt;!--/*--&gt;
          &lt;tr&gt;
            &lt;td&gt;The First Losers (TFL)&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;points&quot;&gt;1&lt;/td&gt;
            &lt;td&gt;Little loser!&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;The Last Losers (TLL)&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td class=&quot;points&quot;&gt;0&lt;/td&gt;
            &lt;td&gt;Big loooooser&lt;/td&gt;
          &lt;/tr&gt;
          &lt;!--*/--&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;

    &lt;/div&gt;

  &lt;/body&gt;

&lt;/html&gt;</code></pre>
<p><em>(Note that we’ve added a second and third rows to our table, surrounded by parser-level comments <code>&lt;!--/* ... */--&gt;</code> so that our template shows nicely as a prototype when directly opened in a browser.)</em></p>
</section>
<section id="changing-the-css-class-by-team-position" class="level2">
<h2>4.2. Changing the CSS class by team position</h2>
<p>The first attribute processor we will develop will be <code>ClassForPositionAttrProcessor</code>, which we will implement as a subclass of a convenience abstract class provided by Thymeleaf called <code>AbstractAttributeModifierAttrProcessor</code>.</p>
<p>This abstract class is already oriented towards creating attribute processors that set or modify the value of attributes in their host tags, which is exactly what we need (we will set a value to the <code>&lt;tr&gt;</code>’s <code>class</code> attribute.</p>
<p>Let’s have a look at our code:</p>
<pre class="java"><code>public class ClassForPositionAttrProcessor
        extends AbstractAttributeModifierAttrProcessor {

    public ClassForPositionAttrProcessor() {
        super(&quot;classforposition&quot;);
    }

    public int getPrecedence() {
        return 12000;
    }

    @Override
    protected Map&lt;String, String&gt; getModifiedAttributeValues(
            final Arguments arguments, final Element element, final String attributeName) {

        final Configuration configuration = arguments.getConfiguration();

        /*
         * Obtain the attribute value
         */
        final String attributeValue = element.getAttributeValue(attributeName);

        /*
         * Obtain the Thymeleaf Standard Expression parser
         */
        final IStandardExpressionParser parser =
                StandardExpressions.getExpressionParser(configuration);

        /*
         * Parse the attribute value as a Thymeleaf Standard Expression
         */
        final IStandardExpression expression =
                parser.parseExpression(configuration, arguments, attributeValue);

        /*
         * Execute the expression just parsed
         */
        final Integer position =
                (Integer) expression.execute(configuration, arguments);

        /*
         * Obtain the remark corresponding to this position in the league table.
         */
        final Remark remark = RemarkUtil.getRemarkForPosition(position);

        /*
         * Apply the corresponding CSS class to the element.
         */
        final Map&lt;String,String&gt; values = new HashMap&lt;String, String&gt;();
        if (remark != null) {
            switch (remark) {
                case WORLD_CHAMPIONS_LEAGUE:
                    values.put(&quot;class&quot;, &quot;wcl&quot;);
                    break;
                case CONTINENTAL_PLAYOFFS:
                    values.put(&quot;class&quot;, &quot;cpo&quot;);
                    break;
                case RELEGATION:
                    values.put(&quot;class&quot;, &quot;rel&quot;);
                    break;
            }
        }

        return values;
    }

    @Override
    protected ModificationType getModificationType(final Arguments arguments, 
            final Element element, final String attributeName, 
            final String newAttributeName) {

        // Just in case there already is a value set for the &#39;class&#39; attribute in the
        // tag, we will append our new value (using a whitespace separator) instead
        // of simply substituting it.
        return ModificationType.APPEND_WITH_SPACE;
    }

    @Override
    protected boolean removeAttributeIfEmpty(final Arguments arguments,
            final Element element, final String attributeName, 
            final String newAttributeName) {

        // If the resulting &#39;class&#39; attribute is empty, do not show it at all.
        return true;
    }

    @Override
    protected boolean recomputeProcessorsAfterExecution(final Arguments arguments,
            final Element element, final String attributeName) {

        // There is no need to recompute the element after this processor has executed
        return false;
    }
}</code></pre>
<p>As you can see, in this case the convenience abstract class we are using abstracts from us any direct modification on the DOM object tree, and instead we just have to create and return a Map with all the new attribute values to be set in the tag.</p>
<p>It is important to note that we are creating this attribute with the ability of executing expressions written in the Standard Syntax (used by both the <em>Standard</em> and the <em>SpringStandard</em> dialects). This is, the ability to be set values like <code>${var}</code>, <code>#{messageKey}</code>, conditionals, etc. See how we use this in our template:</p>
<pre class="html"><code>&lt;tr th:each=&quot;t : ${teams}&quot; score:classforposition=&quot;${tStat.count}&quot;&gt;</code></pre>
<p>In order to evaluate these expressions (also called <em>Thymeleaf Standard Expressions</em>) we need to first obtain the Standard Expression Parser, then parse the attribute value, and finally execute the parsed expresion:</p>
<pre class="java"><code>final IStandardExpressionParser parser =
        StandardExpressions.getExpressionParser(configuration);

final IStandardExpression expression =
        parser.parseExpression(configuration, arguments, attributeValue);

final Integer position =
        (Integer) expression.execute(configuration, arguments);</code></pre>
</section>
<section id="displaying-an-internationalized-remark" class="level2">
<h2>4.3. Displaying an internationalized remark</h2>
<p>The next thing to do is creating an attribute processor able to display the remark text. This will be very similar to the <code>ClassForPositionAttrProcessor</code>, but with a couple of important differences:</p>
<ul>
<li>We will not be setting a value for an attribute in the host tag, but rather the text body (content) of the tag, in the same way a <code>th:text</code> attribute does.</li>
<li>We need to access the message externalization (internationalization) system from our code so that we can display the text corresponding to the selected locale.</li>
</ul>
<p>This time we will be using a different convenience abstract class —one especially designed for setting the tag’s text content—, <code>AbstractTextChildModifierAttrProcessor</code>. And this will be our code:</p>
<pre class="java"><code>public class RemarkForPositionAttrProcessor
        extends AbstractTextChildModifierAttrProcessor {

    public RemarkForPositionAttrProcessor() {
        super(&quot;remarkforposition&quot;);
    }

    public int getPrecedence() {
        return 12000;
    }

    @Override
    protected String getText(
            final Arguments arguments, final Element element, final String attributeName) {

        final Configuration configuration = arguments.getConfiguration();

        /*
         * Obtain the attribute value
         */
        final String attributeValue = element.getAttributeValue(attributeName);

        /*
         * Obtain the Thymeleaf Standard Expression parser
         */
        final IStandardExpressionParser parser =
                StandardExpressions.getExpressionParser(configuration);

        /*
         * Parse the attribute value as a Thymeleaf Standard Expression
         */
        final IStandardExpression expression =
                parser.parseExpression(configuration, arguments, attributeValue);

        /*
         * Execute the expression just parsed
         */
        final Integer position =
                (Integer) expression.execute(configuration, arguments);

        /*
         * Obtain the remark corresponding to this position in the leaguh table.
         */
        final Remark remark = RemarkUtil.getRemarkForPosition(position);

        /*
         * If no remark is to be applied, just return an empty message
         */
        if (remark == null) {
            return &quot;&quot;;
        }

        /*
         * Message should be internationalized, so we ask the engine to resolve the message
         * &#39;remarks.{REMARK}&#39; (e.g. &#39;remarks.RELEGATION&#39;). No parameters are needed for this
         * message.
         */
        return getMessage(arguments, &quot;remarks.&quot; + remark.toString(), new Object[0]);

    }

}</code></pre>
<p>Note that we are accessing the message externalization system with:</p>
<pre class="java"><code>return getMessage(arguments, &quot;remarks.&quot; + remark.toString(), new Object[0]);</code></pre>
<p>But this in fact is not the only way. As previously mentioned in this guide, the <code>AbstractProcessor</code> class offers three methods for obtaining externalized messages from attribute processors. The first two make a difference between <em>template messages</em> and <em>processor messages</em>:</p>
<pre class="java"><code>protected String getMessageForTemplate(
        final Arguments arguments, final TemplateResolution templateResolution,
        final String messageKey, final Object[] messageParameters);

protected String getMessageForProcessor(
        final Arguments arguments, final String messageKey,
        final Object[] messageParameters);</code></pre>
<p><code>getMessageForTemplate(...)</code> uses the Template Engine’s currently registered externalization mechanisms to look for the desired message. For example:</p>
<ul>
<li>In a Spring application, we will probably be using specific Message Resolvers that query the Spring MessageSource objects registered for the application.</li>
<li>When not in a Spring application, we will probably be using Thymeleaf’s Standard Message Resolver that looks for <code>.properties</code> files with the same name as the template being processed.</li>
</ul>
<p><code>getMessageForProcessor(...)</code> uses a message resolution mechanism created for allowing the componentization -or, if you prefer, encapsulation- of dialects. This mechanism consists in allowing tag and attribute processors to specify their own messages, whichever the application their dialects are used on. These are read from <code>.properties</code> files with the same name and living in the same package as the processor class (or any of its superclasses). For example, the <code>thymeleafexamples.extrathyme.dialects.score</code> package in our example could contain:</p>
<ul>
<li><code>RemarkForPositionAttrProcessor.java</code>: the attribute processor.</li>
<li><code>RemarkForPositionAttrProcessor_en_GB.properties</code>: externalized messages for English (UK) language.</li>
<li><code>RemarkForPositionAttrProcessor_en.properties</code>: externalized messages for English (rest of countries) language.</li>
<li><code>RemarkForPositionAttrProcessor.properties</code>: default externalized messages.</li>
</ul>
<p>Finally, there is a third method, the one we used in our code:</p>
<pre class="java"><code>protected String getMessage(
        final Arguments arguments, final TemplateResolution templateResolution,
        final String messageKey, final Object[] messageParameters);</code></pre>
<p>This <code>getMessage(...)</code> acts as a combination of the other two: first it tries to resolve the required message as a template message (defined in the application messages files) and if it doesn’t exist tries to resolve it as a processor message. This way, applications can override —if needed— any messages stablished by its dialects’ processors.</p>
</section>
<section id="an-element-processor-for-our-headlines" class="level2">
<h2>4.4. An element processor for our headlines</h2>
<p>The third and last processor we will have to write is an element (tag) processor. As their name implies, element processors are triggered by element names instead of attribute names, and they have one advantage and also one disadvantage with respect to attribute processors:</p>
<ul>
<li>Advantage: elements can contain multiple attributes, and so your element processors can receive a richer and more complex set of configuration parameters.</li>
<li>Disadvantage: custom elements/tags are unknown to browsers, and so if you are developing a web application using custom tags you might have to sacrifice one of the most interesting features of Thymeleaf: the ability to statically display templates as prototypes (something called <em>natural templating</em>)</li>
</ul>
<p>This processor will extend <code>org.thymeleaf.processor.element.AbstractElementProcessor</code>, but as we did with our attribute processors, instead of extending it directly, we will use a more specialized abstract convenience class as a base for our processor class: <code>AbstractMarkupSubstitutionElementProcessor</code>. This is a base element processor that simply expects you to generate the DOM nodes that will substitute the host tag when the template is processed.</p>
<p>And this is our code:</p>
<pre class="java"><code>public class HeadlinesElementProcessor extends AbstractMarkupSubstitutionElementProcessor {

    private final Random rand = new Random(System.currentTimeMillis());

    public HeadlinesElementProcessor() {
        super(&quot;headlines&quot;);
    }

    public int getPrecedence() {
        return 1000;
    }

    @Override
    protected List&lt;Node&gt; getMarkupSubstitutes(
            final Arguments arguments, final Element element) {

        /*
         * Obtain the Spring application context. Being a SpringMVC-based
         * application, we know that the IContext implementation being
         * used is SpringWebContext, and so we can directly cast and ask it
         * to return the AppCtx.
         */
        final ApplicationContext appCtx =
            ((SpringWebContext)arguments.getContext()).getApplicationContext();

        /*
         * Obtain the HeadlineRepository bean from the application context, and ask
         * it for the current list of headlines.
         */
        final HeadlineRepository headlineRepository = 
                appCtx.getBean(HeadlineRepository.class);
        final List&lt;Headline&gt; headlines = headlineRepository.findAllHeadlines();

        /*
         * Read the &#39;order&#39; attribute from the tag. This optional attribute in our tag
         * will allow us to determine whether we want to show a random headline or
         * only the latest one (&#39;latest&#39; is default).
         */
        final String order = element.getAttributeValue(&quot;order&quot;);

        String headlineText = null;
        if (order != null &amp;&amp; order.trim().toLowerCase().equals(&quot;random&quot;)) {
            // Order is random
            final int r = this.rand.nextInt(headlines.size());
            headlineText = headlines.get(r).getText();
        } else {
            // Order is &quot;latest&quot;, only the latest headline will be shown
            Collections.sort(headlines); headlineText = 
                    headlines.get(headlines.size() - 1).getText();
        }

        /*
         * Create the DOM structure that will be substituting our custom tag.
         * The headline will be shown inside a &#39;&lt;div&gt;&#39; tag, and so this must
         * be created first and then a Text node must be added to it.
         */
        final Element container = new Element(&quot;div&quot;);
        container.setAttribute(&quot;class&quot;, &quot;headlines&quot;);

        final Text text = new Text(headlineText);
        container.addChild(text);

        /*
         * The abstract IAttrProcessor implementation we are using defines
         * that a list of nodes will be returned, and that these nodes
         * will substitute the tag we are processing.
         */
        final List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();
        nodes.add(container); return nodes;

    }

}</code></pre>
<p>Not much new to see here, except for the fact that we are accessing Spring’s <code>ApplicationContext</code> in order to obtain one of our beans from it (the <code>HeadlineRepository</code>).</p>
<p>Note also how we can access the custom tag’s order attribute as we would with any other DOM element:</p>
<pre class="java"><code>final String order = element.getAttributeValue(&quot;order&quot;);</code></pre>
</section>
<section id="declaring-it-all-the-dialect" class="level2">
<h2>4.5. Declaring it all: the Dialect</h2>
<p>The last step we need to take in order to complete our dialect is, of course, the dialect class itself.</p>
<p>Dialect classes must implement the <code>org.thymeleaf.dialect.IDialect</code> interface, but again we will here use an abstract convenience implementation that allows us to only implement the methods we need, returning a default (empty) value for the rest of them.</p>
<p>Here’s the code, quite easy to follow by now:</p>
<pre class="java"><code>public class ScoreDialect extends AbstractDialect {

    /*
     * Default prefix: this is the prefix that will be used for this dialect
     * unless a different one is specified when adding the dialect to
     * the Template Engine.
     */
    public String getPrefix() {
        return &quot;score&quot;;
    }

    /*
     * Two attribute processors are declared: &#39;classforposition&#39; and
     * &#39;remarkforposition&#39;. Also one element processor: the &#39;headlines&#39;
     * tag.
     */
    @Override
    public Set&lt;IProcessor&gt; getProcessors() {
        final Set&lt;IProcessor&gt; processors = new HashSet&lt;IProcessor&gt;();
        processors.add(new ClassForPositionAttrProcessor());
        processors.add(new RemarkForPositionAttrProcessor());
        processors.add(new HeadlinesElementProcessor());
        return processors;
    }

}</code></pre>
<p>Once our dialect is created, we will need to declare it for use from our Template Engine. We will use the <code>additionalDialects</code> property in the template engine so that we add our dialect to the Spring Standard one (declared by default).</p>
<p>Let’s see how we’d configure this in our Spring bean configuration files:</p>
<pre class="xml"><code>&lt;bean id=&quot;templateEngine&quot;
      class=&quot;org.thymeleaf.spring4.SpringTemplateEngine&quot;&gt;
  &lt;property name=&quot;templateResolver&quot; ref=&quot;templateResolver&quot; /&gt;
  &lt;property name=&quot;additionalDialects&quot;&gt;
    &lt;set&gt;
      &lt;bean class=&quot;thymeleafexamples.extrathyme.dialects.score.ScoreDialect&quot; /&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<p>And that’s it! Our dialect is ready to run now, and our league table will display in exactly the way we wanted.</p>
</section>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>European football, of course ;-)<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
		</div>

	</div>

</body>

</html>
