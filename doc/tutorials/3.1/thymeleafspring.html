<!DOCTYPE html>

<html lang="en">

<head>
	<title>Tutorial: Thymeleaf + Spring</title>
	<meta charset="utf-8">
	<meta name="generator" content="pandoc">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<meta name="format-detection" content="telephone=no"/>

	<link rel="icon" href="../../images/favicon.ico"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,400italic,700,700italic"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/2.1.3/normalize.min.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-screen.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-print.css" media="print"/>

	<script src="https://unpkg.com/dumb-query-selector@3.0.0/dumb-query-selector.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-core.min.js" defer data-manual></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-markup.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-java.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/line-numbers/prism-line-numbers.min.js" defer></script>
	<script src="../../scripts/thymeleaf-tutorials.js" defer></script>

</head>

<body class="tutorial">

	<div class="toc-wrapper toolbar-container">
		<div class="toolbar-menu">
			<div id="toolbar-location" class="toolbar-menu-location"></div>
			<button id="site-menu-button" type="button" class="toolbar-menu-button">Doc Contents</button>
		</div>
		<nav id="toc">
			<ul>
<li><a href="#preface" id="toc-preface">Preface</a></li>
<li><a href="#integrating-thymeleaf-with-spring" id="toc-integrating-thymeleaf-with-spring">1 Integrating Thymeleaf with Spring</a></li>
<li><a href="#the-springstandard-dialect" id="toc-the-springstandard-dialect">2 The SpringStandard Dialect</a></li>
<li><a href="#views-and-view-resolvers" id="toc-views-and-view-resolvers">3 Views and View Resolvers</a>
<ul>
<li><a href="#views-and-view-resolvers-in-spring-mvc" id="toc-views-and-view-resolvers-in-spring-mvc">3.1 Views and View Resolvers in Spring MVC</a></li>
<li><a href="#views-and-view-resolvers-in-thymeleaf" id="toc-views-and-view-resolvers-in-thymeleaf">3.2 Views and View Resolvers in Thymeleaf</a></li>
</ul></li>
<li><a href="#spring-thyme-seed-starter-manager" id="toc-spring-thyme-seed-starter-manager">4 Spring Thyme Seed Starter Manager</a>
<ul>
<li><a href="#the-concept" id="toc-the-concept">4.1 The Concept</a></li>
<li><a href="#business-layer" id="toc-business-layer">4.2 Business Layer</a></li>
<li><a href="#spring-mvc-configuration" id="toc-spring-mvc-configuration">4.3 Spring MVC configuration</a></li>
<li><a href="#the-controller" id="toc-the-controller">4.4 The Controller</a>
<ul>
<li><a href="#model-attributes" id="toc-model-attributes">Model Attributes</a></li>
<li><a href="#mapped-methods" id="toc-mapped-methods">Mapped methods</a></li>
</ul></li>
<li><a href="#configuring-a-conversion-service" id="toc-configuring-a-conversion-service">4.5 Configuring a Conversion Service</a></li>
</ul></li>
<li><a href="#listing-seed-starter-data" id="toc-listing-seed-starter-data">5 Listing Seed Starter Data</a></li>
<li><a href="#creating-a-form" id="toc-creating-a-form">6 Creating a Form</a>
<ul>
<li><a href="#handling-the-command-object" id="toc-handling-the-command-object">6.1 Handling the command object</a></li>
<li><a href="#inputs" id="toc-inputs">6.2 Inputs</a></li>
<li><a href="#checkbox-fields" id="toc-checkbox-fields">6.3 Checkbox fields</a></li>
<li><a href="#radio-button-fields" id="toc-radio-button-fields">6.4 Radio Button fields</a></li>
<li><a href="#dropdownlist-selectors" id="toc-dropdownlist-selectors">6.5 Dropdown/List selectors</a></li>
<li><a href="#dynamic-fields" id="toc-dynamic-fields">6.6 Dynamic fields</a></li>
</ul></li>
<li><a href="#validation-and-error-messages" id="toc-validation-and-error-messages">7 Validation and Error Messages</a>
<ul>
<li><a href="#field-errors" id="toc-field-errors">7.1 Field errors</a>
<ul>
<li><a href="#simplifying-error-based-css-styling-therrorclass" id="toc-simplifying-error-based-css-styling-therrorclass">Simplifying error-based CSS styling: <code>th:errorclass</code></a></li>
</ul></li>
<li><a href="#all-errors" id="toc-all-errors">7.2 All errors</a></li>
<li><a href="#global-errors" id="toc-global-errors">7.3 Global errors</a></li>
<li><a href="#displaying-errors-outside-forms" id="toc-displaying-errors-outside-forms">7.4 Displaying errors outside forms</a></li>
<li><a href="#rich-error-objects" id="toc-rich-error-objects">7.5 Rich error objects</a></li>
</ul></li>
<li><a href="#its-still-a-prototype" id="toc-its-still-a-prototype">8 It’s still a Prototype!</a></li>
<li><a href="#the-conversion-service" id="toc-the-conversion-service">9 The Conversion Service</a>
<ul>
<li><a href="#configuration" id="toc-configuration">9.1 Configuration</a></li>
<li><a href="#double-brace-syntax" id="toc-double-brace-syntax">9.1 Double-brace syntax</a></li>
<li><a href="#use-in-forms" id="toc-use-in-forms">9.2 Use in forms</a></li>
<li><a href="#conversions-utility-object" id="toc-conversions-utility-object">9.3 <code>#conversions</code> utility object</a></li>
</ul></li>
<li><a href="#rendering-template-fragments" id="toc-rendering-template-fragments">10 Rendering Template Fragments</a>
<ul>
<li><a href="#specifying-fragments-in-view-beans" id="toc-specifying-fragments-in-view-beans">10.1 Specifying fragments in view beans</a></li>
<li><a href="#specifying-fragments-in-controller-return-values" id="toc-specifying-fragments-in-controller-return-values">10.2 Specifying fragments in controller return values</a></li>
</ul></li>
<li><a href="#advanced-integration-features" id="toc-advanced-integration-features">11 Advanced Integration Features</a>
<ul>
<li><a href="#integration-with-requestdatavalueprocessor" id="toc-integration-with-requestdatavalueprocessor">11.1 Integration with <code>RequestDataValueProcessor</code></a></li>
<li><a href="#building-uris-to-controllers" id="toc-building-uris-to-controllers">11.1 Building URIs to controllers</a></li>
</ul></li>
<li><a href="#spring-webflow-integration" id="toc-spring-webflow-integration">12 Spring WebFlow integration</a>
<ul>
<li><a href="#basic-configuration" id="toc-basic-configuration">12.1 Basic configuration</a></li>
<li><a href="#ajax-fragments-in-spring-webflow" id="toc-ajax-fragments-in-spring-webflow">12.2 AJAX fragments in Spring WebFlow</a></li>
</ul></li>
</ul>
		</nav>
	</div>

	<div class="content-wrapper">

		<div class="title-container">
			<header class="hero-header fluid-block">
				<div class="hero-header-text">
					<h1 class="hero-header-title">Thymeleaf</h1>
				</div>
				<div class="hero-header-image">
					<img src="../../images/thymeleaf.png" alt="Thymeleaf logo" class="hero-header-logo"/>
				</div>
			</header>

			<div class="tutorial-info fluid-block">
				<h1 id="tutorial-title" class="tutorial-title">Tutorial: Thymeleaf + Spring</h1>
								<div class="tutorial-metadata">
					<div id="tutorial-version">
						<span class="tutorial-metadata-label">Document version:</span> 20230730 - 30 July 2023
					</div>
					<div id="project-version">
						<span class="tutorial-metadata-label">Project version:</span> 3.1.2.RELEASE
					</div>
					<div id="project-website">
						<span class="tutorial-metadata-label">Project web site:</span>
						<a href="https://www.thymeleaf.org">https://www.thymeleaf.org</a>
					</div>
				</div>
			</div>
		</div>

		<div id="content" class="fluid-block">
			<section id="preface" class="level1">
<h1>Preface</h1>
<p>This tutorial explains how Thymeleaf can be integrated with the Spring Framework, especially (but not only) Spring MVC.</p>
<p>Note that Thymeleaf has integrations for both versions 5.x and 6.x of the Spring Framework, provided by two separate libraries called <code>thymeleaf-spring5</code> and <code>thymeleaf-spring6</code>. These libraries are packaged in separate <code>.jar</code> files (<code>thymeleaf-spring5-{version}.jar</code> and <code>thymeleaf-spring6-{version}.jar</code>) and need to be added to your classpath in order to use Thymeleaf’s Spring integrations in your application.</p>
<p>The code samples and example application in this tutorial make use of <strong>Spring 6.x</strong> and its corresponding Thymeleaf integrations, but the contents of this text are valid also for Spring 5.x. If your application uses Spring 5.x, all you have to do is replace the <code>org.thymeleaf.spring6</code> package with <code>org.thymeleaf.spring5</code> in the code samples.</p>
</section>
<section id="integrating-thymeleaf-with-spring" class="level1">
<h1>1 Integrating Thymeleaf with Spring</h1>
<p>Thymeleaf offers a set of Spring integrations that allow you to use it as a fully-featured substitute for JSP in Spring MVC applications.</p>
<p>These integrations will allow you to:</p>
<ul>
<li>Make the mapped methods in your Spring MVC <code>@Controller</code> objects forward to templates managed by Thymeleaf, exactly like you do with JSPs.</li>
<li>Use <strong>Spring Expression Language</strong> (Spring EL) instead of OGNL in your templates.</li>
<li>Create forms in your templates that are completely integrated with your form-backing beans and result bindings, including the use of property editors, conversion services and validation error handling.</li>
<li>Display internationalization messages from message files managed by Spring (through the usual <code>MessageSource</code> objects).</li>
<li>Resolve your templates using Spring’s own resource resolution mechanisms.</li>
</ul>
<p>Note that in order to fully understand this tutorial, you should have first gone through the <em>“Using Thymeleaf”</em> tutorial, which explains the Standard Dialect in depth.</p>
</section>
<section id="the-springstandard-dialect" class="level1">
<h1>2 The SpringStandard Dialect</h1>
<p>In order to achieve an easier and better integration, Thymeleaf provides a dialect which specifically implements all the needed features for it to work correctly with Spring.</p>
<p>This specific dialect is based on the Thymeleaf Standard Dialect and is implemented in a class called <code>org.thymeleaf.spring6.dialect.SpringStandardDialect</code>, which in fact extends from <code>org.thymeleaf.standard.StandardDialect</code>.</p>
<p>Besides all the features already present in the Standard Dialect –and therefore inherited–, the SpringStandard Dialect introduces the following specific features:</p>
<ul>
<li>Use Spring Expression Language (Spring EL or SpEL) as a variable expression language, instead of OGNL. Consequently, all <code>${...}</code> and <code>*{...}</code> expressions will be evaluated by Spring’s Expression Language engine. Note also that support for the Spring EL compiler is available.</li>
<li>Access any beans in your application context using SpringEL’s syntax: <code>${@myBean.doSomething()}</code></li>
<li>New attributes for form processing: <code>th:field</code>, <code>th:errors</code> and <code>th:errorclass</code>, besides a new implementation of <code>th:object</code> that allows it to be used for form command selection.</li>
<li>An expression object and method, <code>#themes.code(...)</code>, which is equivalent to the <code>spring:theme</code> JSP custom tag.</li>
<li>An expression object and method, <code>#mvc.uri(...)</code>, which is equivalent to the <code>spring:mvcUrl(...)</code> JSP custom function.</li>
</ul>
<p>Note that most of the times <em>you shouldn’t be using this dialect directly in a normal <code>TemplateEngine</code> object</em> as a part of its configuration. Unless you have very specific Spring integration needs, you should instead be creating an instance of a new template engine class that performs all the required configuration steps automatically: <code>org.thymeleaf.spring6.SpringTemplateEngine</code>.</p>
<p>An example bean configuration:</p>
<pre class="java"><code>@Bean
public SpringResourceTemplateResolver templateResolver(){
    // SpringResourceTemplateResolver automatically integrates with Spring&#39;s own
    // resource resolution infrastructure, which is highly recommended.
    SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();
    templateResolver.setApplicationContext(this.applicationContext);
    templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);
    templateResolver.setSuffix(&quot;.html&quot;);
    // HTML is the default value, added here for the sake of clarity.
    templateResolver.setTemplateMode(TemplateMode.HTML);
    // Template cache is true by default. Set to false if you want
    // templates to be automatically updated when modified.
    templateResolver.setCacheable(true);
    return templateResolver;
}

@Bean
public SpringTemplateEngine templateEngine(){
    // SpringTemplateEngine automatically applies SpringStandardDialect and
    // enables Spring&#39;s own MessageSource message resolution mechanisms.
    SpringTemplateEngine templateEngine = new SpringTemplateEngine();
    templateEngine.setTemplateResolver(templateResolver());
    // Enabling the SpringEL compiler with Spring 4.2.4 or newer can
    // speed up execution in most scenarios, but might be incompatible
    // with specific cases when expressions in one template are reused
    // across different data types, so this flag is &quot;false&quot; by default
    // for safer backwards compatibility.
    templateEngine.setEnableSpringELCompiler(true);
    return templateEngine;
}</code></pre>
<p>Or, using Spring’s XML-based configuration:</p>
<pre class="xml"><code>&lt;!-- SpringResourceTemplateResolver automatically integrates with Spring&#39;s own --&gt;
&lt;!-- resource resolution infrastructure, which is highly recommended.          --&gt;
&lt;bean id=&quot;templateResolver&quot;
       class=&quot;org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver&quot;&gt;
  &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot; /&gt;
  &lt;property name=&quot;suffix&quot; value=&quot;.html&quot; /&gt;
  &lt;!-- HTML is the default value, added here for the sake of clarity.          --&gt;
  &lt;property name=&quot;templateMode&quot; value=&quot;HTML&quot; /&gt;
  &lt;!-- Template cache is true by default. Set to false if you want             --&gt;
  &lt;!-- templates to be automatically updated when modified.                    --&gt;
  &lt;property name=&quot;cacheable&quot; value=&quot;true&quot; /&gt;
&lt;/bean&gt;
    
&lt;!-- SpringTemplateEngine automatically applies SpringStandardDialect and      --&gt;
&lt;!-- enables Spring&#39;s own MessageSource message resolution mechanisms.         --&gt;
&lt;bean id=&quot;templateEngine&quot;
      class=&quot;org.thymeleaf.spring6.SpringTemplateEngine&quot;&gt;
  &lt;property name=&quot;templateResolver&quot; ref=&quot;templateResolver&quot; /&gt;
  &lt;!-- Enabling the SpringEL compiler can speed up execution in most           --&gt;
  &lt;!-- scenarios, but might be incompatible with specific cases when           --&gt;
  &lt;!-- expressions in one template are reused across different data types, so  --&gt;
  &lt;!-- this flag is &quot;false&quot; by default for safer backwards compatibility.      --&gt;
  &lt;property name=&quot;enableSpringELCompiler&quot; value=&quot;true&quot; /&gt;
&lt;/bean&gt;</code></pre>
</section>
<section id="views-and-view-resolvers" class="level1">
<h1>3 Views and View Resolvers</h1>
<section id="views-and-view-resolvers-in-spring-mvc" class="level2">
<h2>3.1 Views and View Resolvers in Spring MVC</h2>
<p>There are two interfaces in Spring MVC that conform the core of its templating system:</p>
<ul>
<li><code>org.springframework.web.servlet.View</code></li>
<li><code>org.springframework.web.servlet.ViewResolver</code></li>
</ul>
<p>Views model pages in our applications and allow us to modify and predefine their behaviour by defining them as beans. Views are in charge of rendering the actual HTML interface, usually by the execution of some template engine like Thymeleaf.</p>
<p>ViewResolvers are the objects in charge of obtaining View objects for a specific operation and locale. Typically, controllers ask ViewResolvers to forward to a view with a specific name (a String returned by the controller method), and then all the view resolvers in the application execute in ordered chain until one of them is able to resolve that view, in which case a View object is returned and control is passed to it for the renderization of HTML.</p>
<blockquote>
<p>Note that not all pages in our applications have to be defined as Views, but only those which behaviour we wish to be non-standard or configured in a specific way (for example, by wiring some special beans to it). If a ViewResolver is asked a view that has no corresponding bean –which is the common case–, a new View object is created ad hoc and returned.</p>
</blockquote>
<p>A typical configuration for a JSP+JSTL ViewResolver in a Spring MVC application from the past looked like this:</p>
<pre class="xml"><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
  &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
  &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot; /&gt;
  &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
  &lt;property name=&quot;order&quot; value=&quot;2&quot; /&gt;
  &lt;property name=&quot;viewNames&quot; value=&quot;*jsp&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p>A quick look at its properties is enough to know about how it was configured:</p>
<ul>
<li><code>viewClass</code> establishes the class of the View instances. This is needed for a JSP resolver, but it will not be needed at all when we’re working with Thymeleaf.</li>
<li><code>prefix</code> and <code>suffix</code> work in a similar way to the attributes of the same names in Thymeleaf’s TemplateResolver objects.</li>
<li><code>order</code> establishes the order in which the ViewResolver will be queried in the chain.</li>
<li><code>viewNames</code> allows the definition (with wildcards) of the view names that will be resolved by this ViewResolver.</li>
</ul>
</section>
<section id="views-and-view-resolvers-in-thymeleaf" class="level2">
<h2>3.2 Views and View Resolvers in Thymeleaf</h2>
<p>Thymeleaf offers implementations for the two interfaces mentioned above:</p>
<ul>
<li><code>org.thymeleaf.spring6.view.ThymeleafView</code></li>
<li><code>org.thymeleaf.spring6.view.ThymeleafViewResolver</code></li>
</ul>
<p>These two classes will be in charge of processing Thymeleaf templates as a result of the execution of controllers.</p>
<p>Configuration of the Thymeleaf View Resolver is very similar to that of JSP:</p>
<pre class="java"><code>@Bean
public ThymeleafViewResolver viewResolver(){
    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
    viewResolver.setTemplateEngine(templateEngine());
    // NOTE &#39;order&#39; and &#39;viewNames&#39; are optional
    viewResolver.setOrder(1);
    viewResolver.setViewNames(new String[] {&quot;.html&quot;, &quot;.xhtml&quot;});
    return viewResolver;
}</code></pre>
<p>…or in XML:</p>
<pre class="xml"><code>&lt;bean class=&quot;org.thymeleaf.spring6.view.ThymeleafViewResolver&quot;&gt;
  &lt;property name=&quot;templateEngine&quot; ref=&quot;templateEngine&quot; /&gt;
  &lt;!-- NOTE &#39;order&#39; and &#39;viewNames&#39; are optional --&gt;
  &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt;
  &lt;property name=&quot;viewNames&quot; value=&quot;*.html,*.xhtml&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p>The <code>templateEngine</code> parameter is, of course, the <code>SpringTemplateEngine</code> object we defined in the previous chapter. The other two (<code>order</code> and <code>viewNames</code>) are both optional, and have the same meaning as in the JSP ViewResolver we saw before.</p>
<p>Note that we do not need <code>prefix</code> or <code>suffix</code> parameters, because these are already specified at the Template Resolver (which in turn is passed to the Template Engine).</p>
<p>And what if we wanted to define a <code>View</code> bean and add some static variables to it? Easy, just define a <em>prototype</em> bean for it:</p>
<pre class="java"><code>@Bean
@Scope(&quot;prototype&quot;)
public ThymeleafView mainView() {
    ThymeleafView view = new ThymeleafView(&quot;main&quot;); // templateName = &#39;main&#39;
    view.setStaticVariables(
        Collections.singletonMap(&quot;footer&quot;, &quot;The ACME Fruit Company&quot;));
    return view;
}</code></pre>
<p>By doing this, you will be able to execute specifically this view bean selecting it by bean name (<code>mainView</code>, in this case).</p>
</section>
</section>
<section id="spring-thyme-seed-starter-manager" class="level1">
<h1>4 Spring Thyme Seed Starter Manager</h1>
<p>The source code for the examples shown in this and future chapters of this guide can be found in the <em>Spring Thyme Seed Starter Manager (STSM)</em> example app:</p>
<ul>
<li><a href="https://github.com/thymeleaf/thymeleaf/tree/3.1-master/examples/spring5/thymeleaf-examples-spring5-stsm">Spring 5 STSM</a>.</li>
<li><a href="https://github.com/thymeleaf/thymeleaf/tree/3.1-master/examples/spring6/thymeleaf-examples-spring6-stsm">Spring 6 STSM</a>.</li>
</ul>
<section id="the-concept" class="level2">
<h2>4.1 The Concept</h2>
<p>At Thymeleaf we’re huge fans of thyme, and every spring we prepare our seed starting kits with good soil and our favourite seeds, place them under the Spanish sun and patiently wait for our new plants to grow.</p>
<p>But this year we got fed up with sticking labels to the seed starter containers for knowing which seed was in each cell of the container, so we decided to prepare an application using Spring MVC and Thymeleaf to help us catalogue our starters: <em>The Spring Thyme SeedStarter Manager</em>.</p>
<figure>
<img src="images/thymeleafspring/stsm-view.png" alt="STSM front page" />
<figcaption aria-hidden="true">STSM front page</figcaption>
</figure>
<p>In a similar way to the Good Thymes Virtual Grocery application we developed in the <em>Using Thymeleaf</em> tutorial, the STSM will allow us to exemplify the most important aspects of the integration of Thymeleaf as a template engine for Spring MVC.</p>
</section>
<section id="business-layer" class="level2">
<h2>4.2 Business Layer</h2>
<p>We will need a very simple business layer for our application. First of all, let’s have a look at our model entities:</p>
<figure>
<img src="images/thymeleafspring/stsm-model.png" alt="STSM model" />
<figcaption aria-hidden="true">STSM model</figcaption>
</figure>
<p>A couple of very simple service classes will provide the required business methods. Like:</p>
<pre class="java"><code>@Service
public class SeedStarterService {

    @Autowired
    private SeedStarterRepository seedstarterRepository; 

    public List&lt;SeedStarter&gt; findAll() {
        return this.seedstarterRepository.findAll();
    }

    public void add(final SeedStarter seedStarter) {
        this.seedstarterRepository.add(seedStarter);
    }

}</code></pre>
<p>And:</p>
<pre class="java"><code>@Service
public class VarietyService {

    @Autowired
    private VarietyRepository varietyRepository; 

    public List&lt;Variety&gt; findAll() {
        return this.varietyRepository.findAll();
    }

    public Variety findById(final Integer id) {
        return this.varietyRepository.findById(id);
    }

}</code></pre>
</section>
<section id="spring-mvc-configuration" class="level2">
<h2>4.3 Spring MVC configuration</h2>
<p>Next we need to set up the Spring MVC configuration for the application, which will include not only the standard Spring MVC artifacts like resource handling or annotation scanning, but also the creation of the Template Engine and View Resolver instances.</p>
<pre class="java"><code>@Configuration
@EnableWebMvc
@ComponentScan
public class SpringWebConfig
        extends WebMvcConfigurerAdapter implements ApplicationContextAware {

    private ApplicationContext applicationContext;


    public SpringWebConfig() {
        super();
    }


    public void setApplicationContext(final ApplicationContext applicationContext)
            throws BeansException {
        this.applicationContext = applicationContext;
    }



    /* ******************************************************************* */
    /*  GENERAL CONFIGURATION ARTIFACTS                                    */
    /*  Static Resources, i18n Messages, Formatters (Conversion Service)   */
    /* ******************************************************************* */

    @Override
    public void addResourceHandlers(final ResourceHandlerRegistry registry) {
        super.addResourceHandlers(registry);
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;/images/&quot;);
        registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;);
        registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;);
    }

    @Bean
    public ResourceBundleMessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename(&quot;Messages&quot;);
        return messageSource;
    }

    @Override
    public void addFormatters(final FormatterRegistry registry) {
        super.addFormatters(registry);
        registry.addFormatter(varietyFormatter());
        registry.addFormatter(dateFormatter());
    }

    @Bean
    public VarietyFormatter varietyFormatter() {
        return new VarietyFormatter();
    }

    @Bean
    public DateFormatter dateFormatter() {
        return new DateFormatter();
    }



    /* **************************************************************** */
    /*  THYMELEAF-SPECIFIC ARTIFACTS                                    */
    /*  TemplateResolver &lt;- TemplateEngine &lt;- ViewResolver              */
    /* **************************************************************** */

    @Bean
    public SpringResourceTemplateResolver templateResolver(){
        // SpringResourceTemplateResolver automatically integrates with Spring&#39;s own
        // resource resolution infrastructure, which is highly recommended.
        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();
        templateResolver.setApplicationContext(this.applicationContext);
        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);
        templateResolver.setSuffix(&quot;.html&quot;);
        // HTML is the default value, added here for the sake of clarity.
        templateResolver.setTemplateMode(TemplateMode.HTML);
        // Template cache is true by default. Set to false if you want
        // templates to be automatically updated when modified.
        templateResolver.setCacheable(true);
        return templateResolver;
    }

    @Bean
    public SpringTemplateEngine templateEngine(){
        // SpringTemplateEngine automatically applies SpringStandardDialect and
        // enables Spring&#39;s own MessageSource message resolution mechanisms.
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver());
        // Enabling the SpringEL compiler with Spring 4.2.4 or newer can
        // speed up execution in most scenarios, but might be incompatible
        // with specific cases when expressions in one template are reused
        // across different data types, so this flag is &quot;false&quot; by default
        // for safer backwards compatibility.
        templateEngine.setEnableSpringELCompiler(true);
        return templateEngine;
    }

    @Bean
    public ThymeleafViewResolver viewResolver(){
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setTemplateEngine(templateEngine());
        return viewResolver;
    }

}</code></pre>
</section>
<section id="the-controller" class="level2">
<h2>4.4 The Controller</h2>
<p>Of course, we will also need a controller for our application. As the STSM will only contain one web page with a list of seed starters and a form for adding new ones, we will write only one controller class for all the server interactions:</p>
<pre class="java"><code>@Controller
public class SeedStarterMngController {

    @Autowired
    private VarietyService varietyService;
    
    @Autowired
    private SeedStarterService seedStarterService;

    ...

}</code></pre>
<p>Now let’s see what we can add to this controller class.</p>
<section id="model-attributes" class="level3">
<h3>Model Attributes</h3>
<p>First we will add some model attributes that we will need in the page:</p>
<pre class="java"><code>@ModelAttribute(&quot;allTypes&quot;)
public List&lt;Type&gt; populateTypes() {
    return Arrays.asList(Type.ALL);
}
    
@ModelAttribute(&quot;allFeatures&quot;)
public List&lt;Feature&gt; populateFeatures() {
    return Arrays.asList(Feature.ALL);
}
    
@ModelAttribute(&quot;allVarieties&quot;)
public List&lt;Variety&gt; populateVarieties() {
    return this.varietyService.findAll();
}
    
@ModelAttribute(&quot;allSeedStarters&quot;)
public List&lt;SeedStarter&gt; populateSeedStarters() {
    return this.seedStarterService.findAll();
}</code></pre>
</section>
<section id="mapped-methods" class="level3">
<h3>Mapped methods</h3>
<p>And now the most important part of a controller, the mapped methods: one for showing the form page, and another one for processing the addition of new <code>SeedStarter</code> objects.</p>
<pre class="java"><code>@RequestMapping({&quot;/&quot;,&quot;/seedstartermng&quot;})
public String showSeedstarters(final SeedStarter seedStarter) {
    seedStarter.setDatePlanted(Calendar.getInstance().getTime());
    return &quot;seedstartermng&quot;;
}

@RequestMapping(value=&quot;/seedstartermng&quot;, params={&quot;save&quot;})
public String saveSeedstarter(
        final SeedStarter seedStarter, final BindingResult bindingResult, final ModelMap model) {
    if (bindingResult.hasErrors()) {
        return &quot;seedstartermng&quot;;
    }
    this.seedStarterService.add(seedStarter);
    model.clear();
    return &quot;redirect:/seedstartermng&quot;;
}</code></pre>
</section>
</section>
<section id="configuring-a-conversion-service" class="level2">
<h2>4.5 Configuring a Conversion Service</h2>
<p>In order to allow easy formatting of <code>Date</code> and also <code>Variety</code> objects in our view layer, we configured our application so that a Spring <code>ConversionService</code> object was created and initialized (by the <code>WebMvcConfigurerAdapter</code> we extend) with a couple of <em>formatter</em> objects we will need. See it again:</p>
<pre class="java"><code>@Override
public void addFormatters(final FormatterRegistry registry) {
    super.addFormatters(registry);
    registry.addFormatter(varietyFormatter());
    registry.addFormatter(dateFormatter());
}

@Bean
public VarietyFormatter varietyFormatter() {
    return new VarietyFormatter();
}

@Bean
public DateFormatter dateFormatter() {
    return new DateFormatter();
}</code></pre>
<p>Spring <em>formatters</em> are implementations of the <code>org.springframework.format.Formatter</code> interface. For more information on how the Spring conversion infrastructure works, see the docs at <a href="http://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/html/validation.html#core-convert">spring.io</a>.</p>
<p>Let’s have a look at the <code>DateFormatter</code>, which formats dates according to a format string present at the <code>date.format</code> message key of our <code>Messages.properties</code>:</p>
<pre class="java"><code>public class DateFormatter implements Formatter&lt;Date&gt; {

    @Autowired
    private MessageSource messageSource;


    public DateFormatter() {
        super();
    }

    public Date parse(final String text, final Locale locale) throws ParseException {
        final SimpleDateFormat dateFormat = createDateFormat(locale);
        return dateFormat.parse(text);
    }

    public String print(final Date object, final Locale locale) {
        final SimpleDateFormat dateFormat = createDateFormat(locale);
        return dateFormat.format(object);
    }

    private SimpleDateFormat createDateFormat(final Locale locale) {
        final String format = this.messageSource.getMessage(&quot;date.format&quot;, null, locale);
        final SimpleDateFormat dateFormat = new SimpleDateFormat(format);
        dateFormat.setLenient(false);
        return dateFormat;
    }

}</code></pre>
<p>The <code>VarietyFormatter</code> automatically converts between our <code>Variety</code> entities and the way we want to use them in our forms (basically, by their <code>id</code> field values):</p>
<pre class="java"><code>public class VarietyFormatter implements Formatter&lt;Variety&gt; {

    @Autowired
    private VarietyService varietyService;


    public VarietyFormatter() {
        super();
    }

    public Variety parse(final String text, final Locale locale) throws ParseException {
        final Integer varietyId = Integer.valueOf(text);
        return this.varietyService.findById(varietyId);
    }


    public String print(final Variety object, final Locale locale) {
        return (object != null ? object.getId().toString() : &quot;&quot;);
    }

}</code></pre>
<p>We will learn more on how these formatters affect the way our data is displayed later on.</p>
</section>
</section>
<section id="listing-seed-starter-data" class="level1">
<h1>5 Listing Seed Starter Data</h1>
<p>The first thing that our <code>/WEB-INF/templates/seedstartermng.html</code> page will show is a listing with the seed starters currently stored. For this we will need some externalized messages and also some expression evaluation on model attributes. Like this:</p>
<pre class="html"><code>&lt;div class=&quot;seedstarterlist&quot; th:unless=&quot;${#lists.isEmpty(allSeedStarters)}&quot;&gt;
    
  &lt;h2 th:text=&quot;#{title.list}&quot;&gt;List of Seed Starters&lt;/h2&gt;
  
  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th th:text=&quot;#{seedstarter.datePlanted}&quot;&gt;Date Planted&lt;/th&gt;
        &lt;th th:text=&quot;#{seedstarter.covered}&quot;&gt;Covered&lt;/th&gt;
        &lt;th th:text=&quot;#{seedstarter.type}&quot;&gt;Type&lt;/th&gt;
        &lt;th th:text=&quot;#{seedstarter.features}&quot;&gt;Features&lt;/th&gt;
        &lt;th th:text=&quot;#{seedstarter.rows}&quot;&gt;Rows&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr th:each=&quot;sb : ${allSeedStarters}&quot;&gt;
        &lt;td th:text=&quot;${{sb.datePlanted}}&quot;&gt;13/01/2011&lt;/td&gt;
        &lt;td th:text=&quot;#{|bool.${sb.covered}|}&quot;&gt;yes&lt;/td&gt;
        &lt;td th:text=&quot;#{|seedstarter.type.${sb.type}|}&quot;&gt;Wireframe&lt;/td&gt;
        &lt;td th:text=&quot;${#strings.arrayJoin(
                           #messages.arrayMsg(
                               #strings.arrayPrepend(sb.features,&#39;seedstarter.feature.&#39;)),
                           &#39;, &#39;)}&quot;&gt;Electric Heating, Turf&lt;/td&gt;
        &lt;td&gt;
          &lt;table&gt;
            &lt;tbody&gt;
              &lt;tr th:each=&quot;row,rowStat : ${sb.rows}&quot;&gt;
                &lt;td th:text=&quot;${rowStat.count}&quot;&gt;1&lt;/td&gt;
                &lt;td th:text=&quot;${row.variety.name}&quot;&gt;Thymus Thymi&lt;/td&gt;
                &lt;td th:text=&quot;${row.seedsPerCell}&quot;&gt;12&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/tbody&gt;
          &lt;/table&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>Lots to see here. Let’s have a look at each fragment separately.</p>
<p>First of all, this section will only be shown if there are any seed starters. We achieve that with a th:unless attribute and the <code>#lists.isEmpty(...)</code> function.</p>
<pre class="html"><code>&lt;div class=&quot;seedstarterlist&quot; th:unless=&quot;${#lists.isEmpty(allSeedStarters)}&quot;&gt;</code></pre>
<p>Note that all utility objects like <code>#lists</code> are available in Spring EL expressions just as they were in OGNL expressions in the Standard Dialect.</p>
<p>The next thing to see is a lot of internationalized (externalized) texts, like:</p>
<pre class="html"><code>&lt;h2 th:text=&quot;#{title.list}&quot;&gt;List of Seed Starters&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th th:text=&quot;#{seedstarter.datePlanted}&quot;&gt;Date Planted&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.covered}&quot;&gt;Covered&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.type}&quot;&gt;Type&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.features}&quot;&gt;Features&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.rows}&quot;&gt;Rows&lt;/th&gt;
      ...</code></pre>
<p>This being a Spring MVC application, we already defined a <code>MessageSource</code> bean in our Spring configuration (<code>MessageSource</code> objects are the standard way of managing externalized texts in Spring MVC):</p>
<pre class="java"><code>@Bean
public ResourceBundleMessageSource messageSource() {
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    messageSource.setBasename(&quot;Messages&quot;);
    return messageSource;
}</code></pre>
<p>…and that <code>basename</code> property indicates that we will have files like <code>Messages_es.properties</code> or <code>Messages_en.properties</code> in our classpath. Let’s have a look at the Spanish version:</p>
<pre class="properties"><code>title.list=Lista de semilleros

date.format=dd/MM/yyyy
bool.true=sí
bool.false=no

seedstarter.datePlanted=Fecha de plantación
seedstarter.covered=Cubierto
seedstarter.type=Tipo
seedstarter.features=Características
seedstarter.rows=Filas

seedstarter.type.WOOD=Madera
seedstarter.type.PLASTIC=Plástico

seedstarter.feature.SEEDSTARTER_SPECIFIC_SUBSTRATE=Sustrato específico para semilleros
seedstarter.feature.FERTILIZER=Fertilizante
seedstarter.feature.PH_CORRECTOR=Corrector de PH</code></pre>
<p>In the first column of the table listing we will show the date when the seed starter was prepared. But <strong>we will show it formatted</strong> in the way we defined in our <code>DateFormatter</code>. In order to do that we will use the double-brace syntax (<code>${{...}}</code>), which will automatically apply the Spring Conversion Service, including the <code>DateFormatter</code> we registered at configuration.</p>
<pre class="html"><code>&lt;td th:text=&quot;${{sb.datePlanted}}&quot;&gt;13/01/2011&lt;/td&gt;</code></pre>
<p>Next is showing whether the seed starter container is covered or not, by transforming the value of the boolean covered bean property into an internationalized <em>“yes”</em> or <em>“no”</em> with a literal substitution expression:</p>
<pre class="html"><code>&lt;td th:text=&quot;#{|bool.${sb.covered}|}&quot;&gt;yes&lt;/td&gt;</code></pre>
<p>Now we have to show the type of seed starter container. Type is a java enum with two values (<code>WOOD</code> and <code>PLASTIC</code>), and that’s why we defined two properties in our <code>Messages</code> file called <code>seedstarter.type.WOOD</code> and <code>seedstarter.type.PLASTIC</code>.</p>
<p>But in order to obtain the internationalized names of the types, we will need to add the <code>seedstarter.type.</code> prefix to the enum value by means of an expression, which result we will then use as the message key:</p>
<pre class="html"><code>&lt;td th:text=&quot;#{|seedstarter.type.${sb.type}|}&quot;&gt;Wireframe&lt;/td&gt;</code></pre>
<p>The most difficult part of this listing is the <em>features</em> column. In it we want to display all the features of our container —that come in the form of an array of <code>Feature</code> enums—, separated by commas. Like <em>“Electric Heating, Turf”</em>.</p>
<p>Note that this is particularly difficult because these enum values also need to be externalized, as we did with Types. The flow is then:</p>
<ol type="1">
<li>Prepend the corresponding prefix to all the elements of the <code>features</code> array.</li>
<li>Obtain the externalized messages corresponding to all the keys from step 1.</li>
<li>Join all the messages obtained in step 2, using a comma as a delimiter.</li>
</ol>
<p>For achieving this, we create the following code:</p>
<pre class="html"><code>&lt;td th:text=&quot;${#strings.arrayJoin(
                   #messages.arrayMsg(
                       #strings.arrayPrepend(sb.features,&#39;seedstarter.feature.&#39;)),
                   &#39;, &#39;)}&quot;&gt;Electric Heating, Turf&lt;/td&gt;</code></pre>
<p>The last column of our listing will be quite simple, in fact. Even if it has a nested table for showing the contents of each row in the container:</p>
<pre class="html"><code>&lt;td&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr th:each=&quot;row,rowStat : ${sb.rows}&quot;&gt;
        &lt;td th:text=&quot;${rowStat.count}&quot;&gt;1&lt;/td&gt;
        &lt;td th:text=&quot;${row.variety.name}&quot;&gt;Thymus Thymi&lt;/td&gt;
        &lt;td th:text=&quot;${row.seedsPerCell}&quot;&gt;12&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/td&gt;</code></pre>
</section>
<section id="creating-a-form" class="level1">
<h1>6 Creating a Form</h1>
<section id="handling-the-command-object" class="level2">
<h2>6.1 Handling the command object</h2>
<p><em>Command object</em> is the name Spring MVC gives to form-backing beans, this is, to objects that model a form’s fields and provide getter and setter methods that will be used by the framework for establishing and obtaining the values input by the user at the browser side.</p>
<p>Thymeleaf requires you to specify the command object by using a <code>th:object</code> attribute in your <code>&lt;form&gt;</code> tag:</p>
<pre class="html"><code>&lt;form action=&quot;#&quot; th:action=&quot;@{/seedstartermng}&quot; th:object=&quot;${seedStarter}&quot; method=&quot;post&quot;&gt;
    ...
&lt;/form&gt;</code></pre>
<p>This is consistent with other uses of <code>th:object,</code> but in fact this specific scenario adds some limitations in order to correctly integrate with Spring MVC’s infrastructure:</p>
<ul>
<li>Values for <code>th:object</code> attributes in form tags must be variable expressions (<code>${...}</code>) specifying only the name of a model attribute, without property navigation. This means that an expression like <code>${seedStarter}</code> is valid, but <code>${seedStarter.data}</code> would not be.</li>
<li>Once inside the <code>&lt;form&gt;</code> tag, no other <code>th:object</code> attribute can be specified. This is consistent with the fact that HTML forms cannot be nested.</li>
</ul>
</section>
<section id="inputs" class="level2">
<h2>6.2 Inputs</h2>
<p>Let’s see now how to add an input to our form:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{datePlanted}&quot; /&gt;</code></pre>
<p>As you can see, we are introducing a new attribute here: <code>th:field.</code> This is a very important feature for Spring MVC integration because it does all the heavy work of binding your input with a property in the form-backing bean. You can see it as an equivalent of the path attribute in a <form:input> tag from Spring MVC’s JSP tag library.</p>
<p>The <code>th:field</code> attribute behaves differently depending on whether it is attached to an <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code> or <code>&lt;textarea&gt;</code> tag (and also depending on the specific type of <code>&lt;input&gt;</code> tag). In this case (<code>input[type=text]</code>), the above line of code is similar to:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; id=&quot;datePlanted&quot; name=&quot;datePlanted&quot; th:value=&quot;*{datePlanted}&quot; /&gt;</code></pre>
<p>…but in fact it is a little bit more than that, because <code>th:field</code> will also apply the registered Spring Conversion Service, including the <code>DateFormatter</code> we saw before (even if the field expression is not double-bracketed). Thanks to this, the date will be shown correctly formatted.</p>
<p>Values for <code>th:field</code> attributes must be selection expressions (<code>*{...}</code>), which makes sense given the fact that they will be evaluated on the form-backing bean and not on the context variables (or model attributes in Spring MVC jargon).</p>
<p>Contrary to the ones in <code>th:object</code>, these expressions can include property navigation (in fact any expression allowed for the path attribute of a <code>&lt;form:input&gt;</code> JSP tag will be allowed here).</p>
<p>Note that <code>th:field</code> also understands the new types of <code>&lt;input&gt;</code> element introduced by HTML5 like <code>&lt;input type="datetime" ... /&gt;</code>, <code>&lt;input type="color" ... /&gt;</code>, etc., effectively adding complete HTML5 support to Spring MVC.</p>
</section>
<section id="checkbox-fields" class="level2">
<h2>6.3 Checkbox fields</h2>
<p><code>th:field</code> also allows us to define checkbox inputs. Let’s see an example from our HTML page:</p>
<pre class="html"><code>&lt;div&gt;
  &lt;label th:for=&quot;${#ids.next(&#39;covered&#39;)}&quot; th:text=&quot;#{seedstarter.covered}&quot;&gt;Covered&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; th:field=&quot;*{covered}&quot; /&gt;
&lt;/div&gt;</code></pre>
<p>Note there’s some fine stuff here besides the checkbox itself, like an externalized label and also the use of the <code>#ids.next('covered')</code> function for obtaining the value that will be applied to the id attribute of the checkbox input.</p>
<p>Why do we need this dynamic generation of an id attribute for this field? Because checkboxes are potentially multi-valued, and thus their id values will always be suffixed a sequence number (by internally using the <code>#ids.seq(...)</code> function) in order to ensure that each of the checkbox inputs for the same property has a different id value.</p>
<p>We can see this more easily if we look at such a multi-valued checkbox field:</p>
<pre class="html"><code>&lt;ul&gt;
  &lt;li th:each=&quot;feat : ${allFeatures}&quot;&gt;
    &lt;input type=&quot;checkbox&quot; th:field=&quot;*{features}&quot; th:value=&quot;${feat}&quot; /&gt;
    &lt;label th:for=&quot;${#ids.prev(&#39;features&#39;)}&quot; 
           th:text=&quot;#{${&#39;seedstarter.feature.&#39; + feat}}&quot;&gt;Heating&lt;/label&gt;
  &lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>Note that we’ve added a <code>th:value</code> attribute this time, because the features field is not a boolean like covered was, but instead is an array of values.</p>
<p>Let’s see the HTML output generated by this code:</p>
<pre class="html"><code>&lt;ul&gt;
  &lt;li&gt;
    &lt;input id=&quot;features1&quot; name=&quot;features&quot; type=&quot;checkbox&quot; value=&quot;SEEDSTARTER_SPECIFIC_SUBSTRATE&quot; /&gt;
    &lt;input name=&quot;_features&quot; type=&quot;hidden&quot; value=&quot;on&quot; /&gt;
    &lt;label for=&quot;features1&quot;&gt;Seed starter-specific substrate&lt;/label&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;input id=&quot;features2&quot; name=&quot;features&quot; type=&quot;checkbox&quot; value=&quot;FERTILIZER&quot; /&gt;
    &lt;input name=&quot;_features&quot; type=&quot;hidden&quot; value=&quot;on&quot; /&gt;
    &lt;label for=&quot;features2&quot;&gt;Fertilizer used&lt;/label&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;input id=&quot;features3&quot; name=&quot;features&quot; type=&quot;checkbox&quot; value=&quot;PH_CORRECTOR&quot; /&gt;
    &lt;input name=&quot;_features&quot; type=&quot;hidden&quot; value=&quot;on&quot; /&gt;
    &lt;label for=&quot;features3&quot;&gt;PH Corrector used&lt;/label&gt;
  &lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>We can see here how a sequence suffix is added to each input’s id attribute, and how the <code>#ids.prev(...)</code> function allows us to retrieve the last sequence value generated for a specific input id.</p>
<blockquote>
<p>Don’t worry about those hidden inputs with <code>name="_features"</code>: they are automatically added in order to avoid problems with browsers not sending unchecked checkbox values to the server upon form submission.</p>
</blockquote>
<p>Also note that if our features property contained some selected values in our form-backing bean, <code>th:field</code>would have taken care of that and would have added a <code>checked="checked"</code> attribute to the corresponding input tags.</p>
</section>
<section id="radio-button-fields" class="level2">
<h2>6.4 Radio Button fields</h2>
<p>Radio button fields are specified in a similar way to non-boolean (multi-valued) checkboxes —except that they are not multivalued, of course:</p>
<pre class="html"><code>&lt;ul&gt;
  &lt;li th:each=&quot;ty : ${allTypes}&quot;&gt;
    &lt;input type=&quot;radio&quot; th:field=&quot;*{type}&quot; th:value=&quot;${ty}&quot; /&gt;
    &lt;label th:for=&quot;${#ids.prev(&#39;type&#39;)}&quot; th:text=&quot;#{${&#39;seedstarter.type.&#39; + ty}}&quot;&gt;Wireframe&lt;/label&gt;
  &lt;/li&gt;
&lt;/ul&gt;</code></pre>
</section>
<section id="dropdownlist-selectors" class="level2">
<h2>6.5 Dropdown/List selectors</h2>
<p>Select fields have two parts: the <code>&lt;select&gt;</code> tag and its nested <code>&lt;option&gt;</code> tags. When creating this kind of field, only the <code>&lt;select&gt;</code> tag has to include a <code>th:field</code> attribute, but the <code>th:value</code> attributes in the nested <code>&lt;option&gt;</code> tags will be very important because they will provide the means of knowing which is the currently selected option (in a similar way to non-boolean checkboxes and radio buttons).</p>
<p>Let’s re-build the type field as a dropdown select:</p>
<pre class="html"><code>&lt;select th:field=&quot;*{type}&quot;&gt;
  &lt;option th:each=&quot;type : ${allTypes}&quot; 
          th:value=&quot;${type}&quot; 
          th:text=&quot;#{${&#39;seedstarter.type.&#39; + type}}&quot;&gt;Wireframe&lt;/option&gt;
&lt;/select&gt;</code></pre>
<p>At this point, understanding this piece of code is quite easy. Just notice how attribute precedence allows us to set the <code>th:each</code> attribute in the <code>&lt;option&gt;</code> tag itself.</p>
</section>
<section id="dynamic-fields" class="level2">
<h2>6.6 Dynamic fields</h2>
<p>Thanks to the advanced form-field binding capabilities in Spring MVC, we can use complex Spring EL expressions to bind dynamic form fields to our form-backing bean. This will allow us to create new Row objects in our <code>SeedStarter</code> bean, and to add those rows’ fields to our form at user request.</p>
<p>In order to do this, we will need a couple of new mapped methods in our controller, which will add or remove a row from our <code>SeedStarter</code> depending on the existence of specific request parameters:</p>
<pre class="java"><code>@RequestMapping(value=&quot;/seedstartermng&quot;, params={&quot;addRow&quot;})
public String addRow(final SeedStarter seedStarter, final BindingResult bindingResult) {
    seedStarter.getRows().add(new Row());
    return &quot;seedstartermng&quot;;
}

@RequestMapping(value=&quot;/seedstartermng&quot;, params={&quot;removeRow&quot;})
public String removeRow(
        final SeedStarter seedStarter, final BindingResult bindingResult, 
        final HttpServletRequest req) {
    final Integer rowId = Integer.valueOf(req.getParameter(&quot;removeRow&quot;));
    seedStarter.getRows().remove(rowId.intValue());
    return &quot;seedstartermng&quot;;
}</code></pre>
<p>And now we can add a dynamic table to our form:</p>
<pre class="html"><code>&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th th:text=&quot;#{seedstarter.rows.head.rownum}&quot;&gt;Row&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.rows.head.variety}&quot;&gt;Variety&lt;/th&gt;
      &lt;th th:text=&quot;#{seedstarter.rows.head.seedsPerCell}&quot;&gt;Seeds per cell&lt;/th&gt;
      &lt;th&gt;
        &lt;button type=&quot;submit&quot; name=&quot;addRow&quot; th:text=&quot;#{seedstarter.row.add}&quot;&gt;Add row&lt;/button&gt;
      &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr th:each=&quot;row,rowStat : *{rows}&quot;&gt;
      &lt;td th:text=&quot;${rowStat.count}&quot;&gt;1&lt;/td&gt;
      &lt;td&gt;
        &lt;select th:field=&quot;*{rows[__${rowStat.index}__].variety}&quot;&gt;
          &lt;option th:each=&quot;var : ${allVarieties}&quot; 
                  th:value=&quot;${var.id}&quot; 
                  th:text=&quot;${var.name}&quot;&gt;Thymus Thymi&lt;/option&gt;
        &lt;/select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;input type=&quot;text&quot; th:field=&quot;*{rows[__${rowStat.index}__].seedsPerCell}&quot; /&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;button type=&quot;submit&quot; name=&quot;removeRow&quot; 
                th:value=&quot;${rowStat.index}&quot; th:text=&quot;#{seedstarter.row.remove}&quot;&gt;Remove row&lt;/button&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
<p>Quite a lot of things to see here, but not much we should not understand by now… except for one <code>strange</code> thing:</p>
<pre class="html"><code>&lt;select th:field=&quot;*{rows[__${rowStat.index}__].variety}&quot;&gt;

    ...

&lt;/select&gt;</code></pre>
<p>If you recall from the <em>“Using Thymeleaf”</em> tutorial, that <code>__${...}__</code> syntax is a preprocessing expression, which is an inner expression that is evaluated before actually evaluating the whole expression. But why that way of specifying the row index? Wouldn’t it be enough with:</p>
<pre class="html"><code>&lt;select th:field=&quot;*{rows[rowStat.index].variety}&quot;&gt;

    ...

&lt;/select&gt;</code></pre>
<p>…well, actually, no. The problem is that Spring EL does not evaluate variables inside array index brackets, so when executing the above expression we would obtain an error telling us that <code>rows[rowStat.index]</code> (instead of <code>rows[0]</code>, <code>rows[1]</code>, etc) is not a valid position in the rows collection. That’s why preprocessing is needed here.</p>
<p>Let’s have a look at a fragment of the resulting HTML after pressing <em>“Add Row”</em> a couple of times:</p>
<pre class="html"><code>&lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;
      &lt;select id=&quot;rows0.variety&quot; name=&quot;rows[0].variety&quot;&gt;
        &lt;option selected=&quot;selected&quot; value=&quot;1&quot;&gt;Thymus vulgaris&lt;/option&gt;
        &lt;option value=&quot;2&quot;&gt;Thymus x citriodorus&lt;/option&gt;
        &lt;option value=&quot;3&quot;&gt;Thymus herba-barona&lt;/option&gt;
        &lt;option value=&quot;4&quot;&gt;Thymus pseudolaginosus&lt;/option&gt;
        &lt;option value=&quot;5&quot;&gt;Thymus serpyllum&lt;/option&gt;
      &lt;/select&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;rows0.seedsPerCell&quot; name=&quot;rows[0].seedsPerCell&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;button name=&quot;removeRow&quot; type=&quot;submit&quot; value=&quot;0&quot;&gt;Remove row&lt;/button&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;
      &lt;select id=&quot;rows1.variety&quot; name=&quot;rows[1].variety&quot;&gt;
        &lt;option selected=&quot;selected&quot; value=&quot;1&quot;&gt;Thymus vulgaris&lt;/option&gt;
        &lt;option value=&quot;2&quot;&gt;Thymus x citriodorus&lt;/option&gt;
        &lt;option value=&quot;3&quot;&gt;Thymus herba-barona&lt;/option&gt;
        &lt;option value=&quot;4&quot;&gt;Thymus pseudolaginosus&lt;/option&gt;
        &lt;option value=&quot;5&quot;&gt;Thymus serpyllum&lt;/option&gt;
      &lt;/select&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;rows1.seedsPerCell&quot; name=&quot;rows[1].seedsPerCell&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;button name=&quot;removeRow&quot; type=&quot;submit&quot; value=&quot;1&quot;&gt;Remove row&lt;/button&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;</code></pre>
</section>
</section>
<section id="validation-and-error-messages" class="level1">
<h1>7 Validation and Error Messages</h1>
<p>Most of our forms will need to show validation messages in order to inform the user of the errors he/she has made.</p>
<p>Thymeleaf offers some tools for this: a couple of functions in the <code>#fields</code> object, the <code>th:errors</code> and the <code>th:errorclass</code> attributes.</p>
<section id="field-errors" class="level2">
<h2>7.1 Field errors</h2>
<p>Let’s see how we could set a specific CSS class to a field if it has an error:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{datePlanted}&quot; 
                   th:class=&quot;${#fields.hasErrors(&#39;datePlanted&#39;)}? fieldError&quot; /&gt;</code></pre>
<p>As you can see, the <code>#fields.hasErrors(...)</code> function receives the field expression as a parameter (<code>datePlanted</code>), and returns a boolean telling whether any validation errors exist for that field.</p>
<p>We could also obtain all the errors for that field and iterate them:</p>
<pre class="html"><code>&lt;ul&gt;
  &lt;li th:each=&quot;err : ${#fields.errors(&#39;datePlanted&#39;)}&quot; th:text=&quot;${err}&quot; /&gt;
&lt;/ul&gt;</code></pre>
<p>Instead of iterating, we could have also used <code>th:errors</code>, a specialized attribute which builds a list with all the errors for the specified selector, separated by <code>&lt;br /&gt;</code>:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{datePlanted}&quot; /&gt;
&lt;p th:if=&quot;${#fields.hasErrors(&#39;datePlanted&#39;)}&quot; th:errors=&quot;*{datePlanted}&quot;&gt;Incorrect date&lt;/p&gt;</code></pre>
<section id="simplifying-error-based-css-styling-therrorclass" class="level3">
<h3>Simplifying error-based CSS styling: <code>th:errorclass</code></h3>
<p>The example we saw above, <em>setting a CSS class to a form input if that field has errors</em>, is so common that Thymeleaf offers a specific attribute for doing exacly that: <code>th:errorclass</code>.</p>
<p>Applied to a form field tag (input, select, textarea…), it will read the name of the field to be examined from any existing <code>name</code> or <code>th:field</code> attributes in the same tag, and then append the specified CSS class to the tag if such field has any associated errors:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{datePlanted}&quot; class=&quot;small&quot; th:errorclass=&quot;fieldError&quot; /&gt;</code></pre>
<p>If <code>datePlanted</code> has errors, this will render as:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; id=&quot;datePlanted&quot; name=&quot;datePlanted&quot; value=&quot;2013-01-01&quot; class=&quot;small fieldError&quot; /&gt;</code></pre>
</section>
</section>
<section id="all-errors" class="level2">
<h2>7.2 All errors</h2>
<p>And what if we want to show all the errors in the form? We just need to query the <code>#fields.hasErrors(...)</code> and <code>#fields.errors(...)</code> methods with the <code>'*'</code> or <code>'all'</code> constants (which are equivalent):</p>
<pre class="html"><code>&lt;ul th:if=&quot;${#fields.hasErrors(&#39;*&#39;)}&quot;&gt;
  &lt;li th:each=&quot;err : ${#fields.errors(&#39;*&#39;)}&quot; th:text=&quot;${err}&quot;&gt;Input is incorrect&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>As in the examples above, we could obtain all the errors and iterate them…</p>
<pre class="html"><code>&lt;ul&gt;
  &lt;li th:each=&quot;err : ${#fields.errors(&#39;*&#39;)}&quot; th:text=&quot;${err}&quot; /&gt;
&lt;/ul&gt;</code></pre>
<p>…as well as build a <code>&lt;br /&gt;</code>-separated list:</p>
<pre class="html"><code>&lt;p th:if=&quot;${#fields.hasErrors(&#39;all&#39;)}&quot; th:errors=&quot;*{all}&quot;&gt;Incorrect date&lt;/p&gt;</code></pre>
<p>Finally note that <code>#fields.hasErrors('*')</code> is equivalent to <code>#fields.hasAnyErrors()</code> and <code>#fields.errors('*')</code> is equivalent to <code>#fields.allErrors()</code>. Use whichever syntax you prefer:</p>
<pre class="html"><code>&lt;div th:if=&quot;${#fields.hasAnyErrors()}&quot;&gt;
  &lt;p th:each=&quot;err : ${#fields.allErrors()}&quot; th:text=&quot;${err}&quot;&gt;...&lt;/p&gt;
&lt;/div&gt;</code></pre>
</section>
<section id="global-errors" class="level2">
<h2>7.3 Global errors</h2>
<p>There is a third type of error in a Spring form: <em>global</em> errors. These are errors that are not associated with any specific fields in the form, but still exist.</p>
<p>Thymeleaf offers the <code>global</code> constant for accessing these errors:</p>
<pre class="html"><code>&lt;ul th:if=&quot;${#fields.hasErrors(&#39;global&#39;)}&quot;&gt;
  &lt;li th:each=&quot;err : ${#fields.errors(&#39;global&#39;)}&quot; th:text=&quot;${err}&quot;&gt;Input is incorrect&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre class="html"><code>&lt;p th:if=&quot;${#fields.hasErrors(&#39;global&#39;)}&quot; th:errors=&quot;*{global}&quot;&gt;Incorrect date&lt;/p&gt;</code></pre>
<p>…as well as equivalent <code>#fields.hasGlobalErrors()</code> and <code>#fields.globalErrors()</code> convenience methods:</p>
<pre class="html"><code>&lt;div th:if=&quot;${#fields.hasGlobalErrors()}&quot;&gt;
  &lt;p th:each=&quot;err : ${#fields.globalErrors()}&quot; th:text=&quot;${err}&quot;&gt;...&lt;/p&gt;
&lt;/div&gt;</code></pre>
</section>
<section id="displaying-errors-outside-forms" class="level2">
<h2>7.4 Displaying errors outside forms</h2>
<p>Form validation errors can also be displayed outside forms by using variable (<code>${...}</code>) instead of selection (<code>*{...}</code>) expressions and prefixing the name of the form-backing bean:</p>
<pre class="html"><code>&lt;div th:errors=&quot;${myForm}&quot;&gt;...&lt;/div&gt;
&lt;div th:errors=&quot;${myForm.date}&quot;&gt;...&lt;/div&gt;
&lt;div th:errors=&quot;${myForm.*}&quot;&gt;...&lt;/div&gt;

&lt;div th:if=&quot;${#fields.hasErrors(&#39;${myForm}&#39;)}&quot;&gt;...&lt;/div&gt;
&lt;div th:if=&quot;${#fields.hasErrors(&#39;${myForm.date}&#39;)}&quot;&gt;...&lt;/div&gt;
&lt;div th:if=&quot;${#fields.hasErrors(&#39;${myForm.*}&#39;)}&quot;&gt;...&lt;/div&gt;

&lt;form th:object=&quot;${myForm}&quot;&gt;
    ...
&lt;/form&gt;</code></pre>
</section>
<section id="rich-error-objects" class="level2">
<h2>7.5 Rich error objects</h2>
<p>Thymeleaf offers the possibility to obtain form error information in the form of beans (instead of mere <em>strings</em>), with the <code>fieldName</code> (String), <code>message</code> (String) and <code>global</code> (boolean) attributes.</p>
<p>These errors can be obtained by means of the <code>#fields.detailedErrors()</code> utility method:</p>
<pre class="html"><code>&lt;ul&gt;
    &lt;li th:each=&quot;e : ${#fields.detailedErrors()}&quot; th:class=&quot;${e.global}? globalerr : fielderr&quot;&gt;
        &lt;span th:text=&quot;${e.global}? &#39;*&#39; : ${e.fieldName}&quot;&gt;The field name&lt;/span&gt; |
        &lt;span th:text=&quot;${e.message}&quot;&gt;The error message&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;</code></pre>
</section>
</section>
<section id="its-still-a-prototype" class="level1">
<h1>8 It’s still a Prototype!</h1>
<p>Our application is ready now. But let’s have a second look at the <code>.html</code> page we created…</p>
<p>One of the nicest consequences of working with Thymeleaf is that after all this functionality we have added to our HTML, we can still use it as a prototype (we say it is a <em>Natural Template</em>). Let’s open <code>seedstartermng.html</code> directly in our browser without executing our application:</p>
<figure>
<img src="images/thymeleafspring/stsm-natural-templating.png" alt="STSM natural templating" />
<figcaption aria-hidden="true">STSM natural templating</figcaption>
</figure>
<p>There it is! It’s not a working application, it’s not real data… but it is a perfectly valid prototype made up of perfectly displayable HTML code.</p>
</section>
<section id="the-conversion-service" class="level1">
<h1>9 The Conversion Service</h1>
<section id="configuration" class="level2">
<h2>9.1 Configuration</h2>
<p>As explained before, Thymeleaf can make use of a Conversion Service registered at the Application Context. Our application configuration class, by extending Spring’s own <code>WebMvcConfigurerAdapter</code> helper, will automatically register such conversion service, which we can configure by adding the <em>formatters</em> that we need. Let’s see again what it looks like:</p>
<pre class="java"><code>@Override
public void addFormatters(final FormatterRegistry registry) {
    super.addFormatters(registry);
    registry.addFormatter(varietyFormatter());
    registry.addFormatter(dateFormatter());
}

@Bean
public VarietyFormatter varietyFormatter() {
    return new VarietyFormatter();
}

@Bean
public DateFormatter dateFormatter() {
    return new DateFormatter();
}</code></pre>
</section>
<section id="double-brace-syntax" class="level2">
<h2>9.1 Double-brace syntax</h2>
<p>The Conversion Service can be easily applied in order to convert/format any object into String. This is done by means of the double-brace expression syntax:</p>
<ul>
<li>For variable expressions: <code>${{...}}</code></li>
<li>For selection expressions: <code>*{{...}}</code></li>
</ul>
<p>So, for example, given an Integer-to-String converter that adds commas as a thousands separator, this:</p>
<pre class="html"><code>&lt;p th:text=&quot;${val}&quot;&gt;...&lt;/p&gt;
&lt;p th:text=&quot;${{val}}&quot;&gt;...&lt;/p&gt;</code></pre>
<p>…should result in:</p>
<pre class="html"><code>&lt;p&gt;1234567890&lt;/p&gt;
&lt;p&gt;1,234,567,890&lt;/p&gt;</code></pre>
</section>
<section id="use-in-forms" class="level2">
<h2>9.2 Use in forms</h2>
<p>We saw before that every <code>th:field</code> attribute will always apply the conversion service, so this:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{datePlanted}&quot; /&gt;</code></pre>
<p>…is actually equivalent to:</p>
<pre class="html"><code>&lt;input type=&quot;text&quot; th:field=&quot;*{{datePlanted}}&quot; /&gt;</code></pre>
<p>Note that, per requirement of Spring, this is the only scenario in which the Conversion Service is applied in expressions using single-brace syntax.</p>
</section>
<section id="conversions-utility-object" class="level2">
<h2>9.3 <code>#conversions</code> utility object</h2>
<p>The <code>#conversions</code> expression utility object allows the manual execution of the Conversion Service wherever needed:</p>
<pre class="html"><code>&lt;p th:text=&quot;${&#39;Val: &#39; + #conversions.convert(val,&#39;String&#39;)}&quot;&gt;...&lt;/p&gt;</code></pre>
<p>Syntax for this utility object:</p>
<ul>
<li><code>#conversions.convert(Object,Class)</code>: converts the object to the specified class.</li>
<li><code>#conversions.convert(Object,String)</code>: same as above, but specifying the target class as a String (note the <code>java.lang.</code> package can be ommitted).</li>
</ul>
</section>
</section>
<section id="rendering-template-fragments" class="level1">
<h1>10 Rendering Template Fragments</h1>
<p>Thymeleaf offers the possibility to render only part of a template as the result of its execution: a <em>fragment</em>.</p>
<p>This can be a useful componentization tool. For example, it can be used at controllers that execute on AJAX calls, which might return markup fragments of a page that is already loaded at the browser (for updating a select, enabling/disabling buttons…).</p>
<p>Fragmentary rendering can be achieved by using Thymeleaf’s <em>fragment specs</em>: objects implementing the <code>org.thymeleaf.fragment.IFragmentSpec</code> interface.</p>
<p>The most common of these implementations is <code>org.thymeleaf.standard.fragment.StandardDOMSelectorFragmentSpec</code>, which allows specifying a fragment using a DOM Selector exactly like the ones used at <code>th:include</code> or <code>th:replace</code>.</p>
<section id="specifying-fragments-in-view-beans" class="level2">
<h2>10.1 Specifying fragments in view beans</h2>
<p><em>View beans</em> are beans of the <code>org.thymeleaf.spring6.view.ThymeleafView</code> class declared at the application context (<code>@Bean</code> declarations if you are using Java configuration). They allow the specification of fragments like this:</p>
<pre class="java"><code>@Bean(name=&quot;content-part&quot;)
@Scope(&quot;prototype&quot;)
public ThymeleafView someViewBean() {
    ThymeleafView view = new ThymeleafView(&quot;index&quot;); // templateName = &#39;index&#39;
    view.setMarkupSelector(&quot;content&quot;);
    return view;
}</code></pre>
<p>Given the above bean definition, if our controller returns <code>content-part</code> (the name of the above bean)…</p>
<pre class="java"><code>@RequestMapping(&quot;/showContentPart&quot;)
public String showContentPart() {
    ...
    return &quot;content-part&quot;;
}</code></pre>
<p>…thymeleaf will return only the <code>content</code> fragment of the <code>index</code> template – which location will probably be something like <code>/WEB-INF/templates/index.html</code>, once prefix and suffix are applied. So the result will be completely equivalent to specifying <code>index :: content</code>:</p>
<pre class="html"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  ...
  &lt;body&gt;
    ...
    &lt;div th:fragment=&quot;content&quot;&gt;
      Only this div will be rendered!
    &lt;/div&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Note also that, thanks to the power of Thymeleaf Markup Selectors, we could select a fragment in a template without needing any <code>th:fragment</code> attributes at all. Let’s use the <code>id</code> attribute, for example:</p>
<pre class="java"><code>@Bean(name=&quot;content-part&quot;)
@Scope(&quot;prototype&quot;)
public ThymeleafView someViewBean() {
    ThymeleafView view = new ThymeleafView(&quot;index&quot;); // templateName = &#39;index&#39;
    view.setMarkupSelector(&quot;#content&quot;);
    return view;
}</code></pre>
<p>…which will perfectly select:</p>
<pre class="html"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  ...
  &lt;body&gt;
    ...
    &lt;div id=&quot;content&quot;&gt;
      Only this div will be rendered!
    &lt;/div&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="specifying-fragments-in-controller-return-values" class="level2">
<h2>10.2 Specifying fragments in controller return values</h2>
<p>Instead of declaring <em>view beans</em>, fragments can be specified from the controllers themselves by using the syntax of <em>fragment expressions</em>. Just like in <code>th:insert</code> or <code>th:replace</code> attributes:</p>
<pre class="java"><code>@RequestMapping(&quot;/showContentPart&quot;)
public String showContentPart() {
    ...
    return &quot;index :: content&quot;;
}</code></pre>
<p>Of course, again the full power of DOM Selectors is available, so we could select our fragment based on standard HTML attributes, like <code>id="content"</code>:</p>
<pre class="java"><code>@RequestMapping(&quot;/showContentPart&quot;)
public String showContentPart() {
    ...
    return &quot;index :: #content&quot;;
}</code></pre>
<p>And we can also use parameters, like:</p>
<pre class="java"><code>@RequestMapping(&quot;/showContentPart&quot;)
public String showContentPart() {
    ...
    return &quot;index :: #content (&#39;myvalue&#39;)&quot;;
}</code></pre>
</section>
</section>
<section id="advanced-integration-features" class="level1">
<h1>11 Advanced Integration Features</h1>
<section id="integration-with-requestdatavalueprocessor" class="level2">
<h2>11.1 Integration with <code>RequestDataValueProcessor</code></h2>
<p>Thymeleaf seamlessly integrates with Spring’s <code>RequestDataValueProcessor</code> interface. This interface allows the interception of link URLs, form URLs and form field values before they are written to the markup result, as well as transparently adding hidden form fields that enable security features like e.g. protection agains CSRF (Cross-Site Request Forgery).</p>
<p>An implementation of <code>RequestDataValueProcessor</code> can be easily configured at the Application Context. It needs to implement the <code>org.springframework.web.servlet.support.RequestDataValueProcessor</code> interface and have <code>requestDataValueProcessor</code> as a bean name:</p>
<pre class="java"><code>@Bean
public RequestDataValueProcessor requestDataValueProcessor() {
  return new MyRequestDataValueProcessor();
}</code></pre>
<p>…and Thymeleaf will use it this way:</p>
<ul>
<li><p><code>th:href</code> and <code>th:src</code> call <code>RequestDataValueProcessor.processUrl(...)</code> before rendering the URL.</p></li>
<li><p><code>th:action</code> calls <code>RequestDataValueProcessor.processAction(...)</code> before rendering the form’s <code>action</code> attribute, and additionally it detects when this attribute is being applied on a <code>&lt;form&gt;</code> tag —which should be the only place, anyway—, and in such case calls <code>RequestDataValueProcessor.getExtraHiddenFields(...)</code> and adds the returned hidden fields just before the closing <code>&lt;/form&gt;</code> tag.</p></li>
<li><p><code>th:value</code> calls <code>RequestDataValueProcessor.processFormFieldValue(...)</code> for rendering the value it refers to, unless there is a <code>th:field</code> present in the same tag (in which case <code>th:field</code> will take care).</p></li>
<li><p><code>th:field</code> calls <code>RequestDataValueProcessor.processFormFieldValue(...)</code> for rendering the value of the field it applies to (or the tag body if it is a <code>&lt;textarea&gt;</code>).</p></li>
</ul>
<blockquote>
<p>Note there are very few scenarios in which you would need to explicitly implement <code>RequestDataValueProcessor</code> in your application. In most cases, this will be used automatically by security libraries you transparently use, like e.g. Spring Security’s CSRF support.</p>
</blockquote>
</section>
<section id="building-uris-to-controllers" class="level2">
<h2>11.1 Building URIs to controllers</h2>
<p>Since version 4.1, Spring allows the possibility to build links to annotated controllers directly from views, without the need to know the URIs these controllers are mapped to.</p>
<p>In Thymeleaf, this can be achieved by means of the <code>#mvc.url(...)</code> expression object method, which allows the specification of controller methods by the capital letters of the controller class they are in, followed by the name of the method itself. This is equivalent to JSP’s <code>spring:mvcUrl(...)</code> custom function.</p>
<p>For example, for:</p>
<pre class="java"><code>public class ExampleController {

    @RequestMapping(&quot;/data&quot;)
    public String getData(Model model) { ... return &quot;template&quot; }

    @RequestMapping(&quot;/data&quot;)
    public String getDataParam(@RequestParam String type) { ... return &quot;template&quot; }

}</code></pre>
<p>The following code will create a link to it:</p>
<pre class="html"><code>&lt;a th:href=&quot;${(#mvc.url(&#39;EC#getData&#39;)).build()}&quot;&gt;Get Data Param&lt;/a&gt;
&lt;a th:href=&quot;${(#mvc.url(&#39;EC#getDataParam&#39;).arg(0,&#39;internal&#39;)).build()}&quot;&gt;Get Data Param&lt;/a&gt;</code></pre>
<p>You can read more about this mechanism at http://docs.spring.io/spring-framework/docs/4.1.2.RELEASE/spring-framework-reference/html/mvc.html#mvc-links-to-controllers-from-views</p>
</section>
</section>
<section id="spring-webflow-integration" class="level1">
<h1>12 Spring WebFlow integration</h1>
<section id="basic-configuration" class="level2">
<h2>12.1 Basic configuration</h2>
<p>The Thymeleaf + Spring integration packages include integration with Spring WebFlow.</p>
<p><em>Note: Spring WebFlow 3.0+ is required when Thymeleaf is used with Spring 6, and Spring WebFlow 2.5 is needed with Spring 5.</em></p>
<p>WebFlow includes some AJAX capabilities for rendering fragments of the displayed page when specific events (<em>transitions</em>) are triggered, and in order to enable Thymeleaf to attend these AJAX requests, we will have to use a different <code>ViewResolver</code> implementation, configured like this:</p>
<pre class="java"><code>@Bean
public FlowDefinitionRegistry flowRegistry() {
    // NOTE: Additional configuration might be needed in your app
    return getFlowDefinitionRegistryBuilder()
            .addFlowLocation(&quot;...&quot;)
            .setFlowBuilderServices(flowBuilderServices())
            .build();
}

@Bean
public FlowExecutor flowExecutor() {
    // NOTE: Additional configuration might be needed in your app
    return getFlowExecutorBuilder(flowRegistry()).build();
}

@Bean
public FlowBuilderServices flowBuilderServices() {
    // NOTE: Additional configuration might be needed in your app
    return getFlowBuilderServicesBuilder()
            .setViewFactoryCreator(viewFactoryCreator())
            .build();
}

@Bean
public ViewFactoryCreator viewFactoryCreator() {
    MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator();
    factoryCreator.setViewResolvers(
            Collections.singletonList(thymeleafViewResolver()));
    factoryCreator.setUseSpringBeanBinding(true);
    return factoryCreator;
}

@Bean
public ViewResolver thymeleafViewResolver() {
    AjaxThymeleafViewResolver viewResolver = new AjaxThymeleafViewResolver();
    // We need to set a special ThymeleafView implementation: FlowAjaxThymeleafView
    viewResolver.setViewClass(FlowAjaxThymeleafView.class);
    viewResolver.setTemplateEngine(templateEngine());
    return viewResolver;
}
</code></pre>
<p>Note the above is not a complete configuration: you will still need to configure your handlers, etc. Refer to the Spring WebFlow documentation for that.</p>
<p>From here on, you can specify Thymeleaf templates in your view-state’s:</p>
<pre class="xml"><code>&lt;view-state id=&quot;detail&quot; view=&quot;bookingDetail&quot;&gt;
    ...
&lt;/view-state&gt;</code></pre>
<p>In the above example, <code>bookingDetail</code> is a Thymeleaf template specified in the usual way, understandable by any of the <em>Template Resolvers</em> configured at the <code>TemplateEngine</code>.</p>
</section>
<section id="ajax-fragments-in-spring-webflow" class="level2">
<h2>12.2 AJAX fragments in Spring WebFlow</h2>
<blockquote>
<p>Note that what is explained here is just the way to create AJAX fragments to be used with Spring WebFlow. If you are not using WebFlow, creating a Spring MVC controller that responds to an AJAX request and returns a chunk of HTML is as straightforward as creating any other template-returning controller, with the only exception that you would probably be returning a fragment like <code>"main :: admin"</code> from your controller method.</p>
</blockquote>
<p>WebFlow allows the specification of fragments to be rendered via AJAX with <code>&lt;render&gt;</code> tags, like this:</p>
<pre class="xml"><code>&lt;view-state id=&quot;detail&quot; view=&quot;bookingDetail&quot;&gt;
    &lt;transition on=&quot;updateData&quot;&gt;
        &lt;render fragments=&quot;hoteldata&quot;/&gt;
    &lt;/transition&gt;
&lt;/view-state&gt;</code></pre>
<p>These fragments (<code>hoteldata</code>, in this case) can be a comma-separated list of fragments specified at the markup with <code>th:fragment</code>:</p>
<pre class="xml"><code>&lt;div id=&quot;data&quot; th:fragment=&quot;hoteldata&quot;&gt;
    This is a content to be changed
&lt;/div&gt;</code></pre>
<p><em>Always remember that the specified fragments must have an <code>id</code> attribute, so that the Spring JavaScript libraries running on the browser are capable of substituting the markup.</em></p>
<p><code>&lt;render&gt;</code> tags can also be specified using DOM selectors:</p>
<pre class="html"><code>&lt;view-state id=&quot;detail&quot; view=&quot;bookingDetail&quot;&gt;
    &lt;transition on=&quot;updateData&quot;&gt;
        &lt;render fragments=&quot;[//div[@id=&#39;data&#39;]]&quot;/&gt;
    &lt;/transition&gt;
&lt;/view-state&gt;</code></pre>
<p>…and this will mean no <code>th:fragment</code> is needed:</p>
<pre class="html"><code>&lt;div id=&quot;data&quot;&gt;
    This is a content to be changed
&lt;/div&gt;</code></pre>
<p>As for the code that triggers the <code>updateData</code> transition, it looks like:</p>
<pre class="html"><code>&lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/resources/dojo/dojo.js}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/resources/spring/Spring.js}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/resources/spring/Spring-Dojo.js}&quot;&gt;&lt;/script&gt;

  ...

&lt;form id=&quot;triggerform&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
    &lt;input type=&quot;submit&quot; id=&quot;doUpdate&quot; name=&quot;_eventId_updateData&quot; value=&quot;Update now!&quot; /&gt;
&lt;/form&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Spring.addDecoration(
        new Spring.AjaxEventDecoration({formId:&#39;triggerform&#39;,elementId:&#39;doUpdate&#39;,event:&#39;onclick&#39;}));
&lt;/script&gt;</code></pre>
</section>
</section>
		</div>

	</div>

</body>

</html>
