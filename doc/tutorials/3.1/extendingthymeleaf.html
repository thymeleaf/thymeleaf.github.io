<!DOCTYPE html>

<html lang="en">

<head>
	<title>Tutorial: Extending Thymeleaf</title>
	<meta charset="utf-8">
	<meta name="generator" content="pandoc">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<meta name="format-detection" content="telephone=no"/>

	<link rel="icon" href="../../images/favicon.ico"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,400italic,700,700italic"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/2.1.3/normalize.min.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials.css"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-screen.css" media="screen"/>
	<link rel="stylesheet" href="../../styles/thymeleaf-tutorials-print.css" media="print"/>

	<script src="https://unpkg.com/dumb-query-selector@3.0.0/dumb-query-selector.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-core.min.js" defer data-manual></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-markup.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-java.min.js" defer></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/line-numbers/prism-line-numbers.min.js" defer></script>
	<script src="../../scripts/thymeleaf-tutorials.js" defer></script>

</head>

<body class="tutorial">

	<div class="toc-wrapper toolbar-container">
		<div class="toolbar-menu">
			<div id="toolbar-location" class="toolbar-menu-location"></div>
			<button id="site-menu-button" type="button" class="toolbar-menu-button">Doc Contents</button>
		</div>
		<nav id="toc">
			<ul><li><a href="#some-reasons-to-extend-thymeleaf">1 Some Reasons to Extend Thymeleaf</a></li><li><a href="#dialects-and-processors">2 Dialects and Processors</a><ul><li><a href="#dialects">2.1. Dialects</a><ul><li><a href="#processor-dialects-iprocessordialect">Processor dialects: <code>IProcessorDialect</code></a></li><li><a href="#pre-processor-dialects-ipreprocessordialect">Pre-processor dialects: <code>IPreProcessorDialect</code></a></li><li><a href="#post-processor-dialects-ipostprocessordialect">Post-processor dialects: <code>IPostProcessorDialect</code></a></li><li><a href="#expression-object-dialects-iexpressionobjectdialect">Expression Object dialects: <code>IExpressionObjectDialect</code></a></li><li><a href="#execution-attribute-dialects-iexecutionattributedialect">Execution Attribute dialects: <code>IExecutionAttributeDialect</code></a></li></ul></li><li><a href="#processors">2.2. Processors</a><ul><li><a href="#element-processors">Element Processors</a></li><li><a href="#element-tag-processors-ielementtagprocessor">Element Tag Processors: <code>IElementTagProcessor</code></a></li><li><a href="#element-model-processors-ielementmodelprocessor">Element Model Processors: <code>IElementModelProcessor</code></a></li><li><a href="#template-startend-processors-itemplateboundariesprocessor">Template start/end Processors: <code>ITemplateBoundariesProcessor</code></a></li><li><a href="#other-processors">Other processors</a></li></ul></li></ul></li><li><a href="#creating-our-own-dialect">3 Creating our own Dialect</a><ul><li><a href="#extrathyme-a-website-for-thymelands-football-league">3.1. extraThyme: a website for Thymeland’s football league</a></li><li><a href="#changing-the-css-class-by-team-position">3.2. Changing the CSS class by team position</a></li><li><a href="#displaying-an-internationalized-remark">3.3. Displaying an internationalized remark</a><ul><li><a href="#accessing-i18n-messages">Accessing i18n messages</a></li><li><a href="#html-escaping-content">HTML-escaping content</a></li></ul></li><li><a href="#an-element-processor-for-our-headlines">3.4. An element processor for our headlines</a><ul><li><a href="#the-model-factory">The Model Factory</a></li></ul></li><li><a href="#a-model-processor-for-our-match-day-today-banner">3.5. A model processor for our “Match Day Today” banner</a></li><li><a href="#declaring-it-all-the-dialect">3.6. Declaring it all: the Dialect</a></li></ul></li></ul>
		</nav>
	</div>

	<div class="content-wrapper">

		<div class="title-container">
			<header class="hero-header fluid-block">
				<div class="hero-header-text">
					<h1 class="hero-header-title">Thymeleaf</h1>
				</div>
				<div class="hero-header-image">
					<img src="../../images/thymeleaf.png" alt="Thymeleaf logo" class="hero-header-logo"/>
				</div>
			</header>

			<div class="tutorial-info fluid-block">
				<h1 id="tutorial-title" class="tutorial-title">Tutorial: Extending Thymeleaf</h1>
								<div class="tutorial-metadata">
					<div id="tutorial-version">
						<span class="tutorial-metadata-label">Document version:</span> 20241209 - 09 December 2024
					</div>
					<div id="project-version">
						<span class="tutorial-metadata-label">Project version:</span> 3.1.3.RELEASE
					</div>
					<div id="project-website">
						<span class="tutorial-metadata-label">Project web site:</span>
						<a href="https://www.thymeleaf.org">https://www.thymeleaf.org</a>
					</div>
				</div>
			</div>
		</div>

		<div id="content" class="fluid-block">
			<section id="some-reasons-to-extend-thymeleaf" class="level1"><h1>1 Some Reasons to Extend Thymeleaf</h1><p>Thymeleaf is an extremely extensible library. The key to it is that most of its user-oriented features are not directly built into its core, but rather just packaged and componentized into feature sets called <em>dialects</em>.</p><p>The library offers you two dialects out-of-the-box: the <em>Standard</em> and the <em>SpringStandard</em> dialects, but you can easily create your own. Let’s explore some of the reasons for doing this:</p><p><strong>Scenario 1: adding features to the Standard dialects</strong></p><p>Say your application uses the <em>SpringStandard</em> dialect and that it needs to show an alert text box in blue or red background depending on the user’s role (admin or non-admin) from Monday to Saturday, but always in green on Sundays. You can compute this with conditional expressions on your template, but too many conditions could render your code a little bit hard to read…</p><p>Solution: create a new attribute called <code>alertclass</code> and an attribute processor for it (Java code that will compute the right CSS class), and package it into your own <code>MyOwnDialect</code> dialect. Add this dialect to your template engine with the <code>th</code> prefix (same as the <em>SpringStandard</em> one) and you’ll now be able to use <code>th:alertclass="${user.role}"</code>!</p><p><strong>Scenario 2: view-layer components</strong></p><p>Let’s say your company uses Thymeleaf extensively, and you want to create a repository of common functionalities (tags and/or attributes) that you can use in several applications without having to copy-paste them from one application to the next. This is, you want to create view-layer components in a similar way to JSPs <em>taglibs</em>.</p><p>Solution: create a Thymeleaf dialect for each set of related functionalities, and add these dialects to your applications as needed. Note that if the tags or attributes in these dialects make use of externalized (internationalized) messages, you will be able to package these messages along with your dialects (in the shape of <em>processor messages</em>) instead of requiring that all of your applications include them in their messages <code>.properties</code> files as you would with JSP.</p><p><strong>Scenario 3: creating your own template system</strong></p><p>Now imagine your are creating a public website that allows users to create their own design templates for showing their content. Of course, you don’t want your users to be able to do absolutely everything in their templates, not even all that the Standard Dialect allows (for example, execute OGNL expressions). So you need to offer your users the ability to add to their templates only a very specific set of features that are under your control (like showing a profile photo, a blog entry text, etc).</p><p>Solution: create a Thymeleaf dialect with the tags or attributes you want your users to be able to use, like <code>&lt;mysite:profilePhoto /&gt;</code> or <code>&lt;mysite:blogentries fromDate="23/4/2011" /&gt;</code>. Then allow your users to create their own templates using these features and just let Thymeleaf execute them, being sure nobody will be doing what they’re not allowed to.</p></section><section id="dialects-and-processors" class="level1"><h1>2 Dialects and Processors</h1><section id="dialects" class="level2"><h2>2.1. Dialects</h2><p>If you’ve read the <em>Using Thymeleaf</em> tutorial before getting here —which you should have done— you should know that what you’ve been learning all this time was not exactly <em>Thymeleaf</em>, but rather its <em>Standard Dialect</em> (or the <em>SpringStandard Dialect</em>, if you’ve also read the <em>Thymeleaf + Spring</em> tutorial).</p><p>What does that mean? It means that all those <code>th:x</code> attributes you learned to use are only a standard, out-of-the-box set of features, but you can define your own set of attributes (or tags) with the names you wish and use them in Thymeleaf to process your templates. <em>You can define your own dialects.</em></p><p>Dialects are objects implementing the <code>org.thymeleaf.dialect.IDialect</code> interface, which cannot be any simpler:</p><pre class="java"><code>public interface IDialect {

    public String getName();

}</code></pre><p>The only core requirement of a dialect is to have a name that can be used for its identification. But this alone is of little use, so dialects will normally implement one or several subinterfaces of <code>IDialect</code>, depending on what they provide to the Thymeleaf engine:</p><ul><li><code>IProcessorDialect</code> for dialects that provide <em>processors</em>.</li><li><code>IPreProcessorDialect</code> for dialects that provide <em>pre-processors</em>.</li><li><code>IPostProcessorDialect</code> for dialects that provide <em>post-processors</em>.</li><li><code>IExpressionObjectDialect</code> for dialects that provide <em>expression objects</em>.</li><li><code>IExecutionAttributeDialect</code> for dialects that provide <em>execution attributes</em>.</li></ul><section id="processor-dialects-iprocessordialect" class="level3"><h3>Processor dialects: <code>IProcessorDialect</code></h3><p>The <code>IProcessorDialect</code> interface looks like this:</p><pre class="java"><code>public interface IProcessorDialect extends IDialect {

    public String getPrefix();
    public int getDialectProcessorPrecedence();
    public Set&lt;IProcessor&gt; getProcessors(final String dialectPrefix);

}</code></pre><p><strong>Processors</strong> are the objects in charge of executing most of the logic in Thymeleaf templates, and possibly the most important Thymeleaf extension artifact. We will cover processors in more detail in next sections.</p><p>This dialect only defines three items:</p><ul><li><p>The <em>prefix</em>, which is the prefix or namespace that should be applied <em>by default</em> to the elements and attributes matched by the dialect’s processors. So a dialect with prefix <code>th</code> like e.g. the <em>Standard Dialect</em> will be able to define processors matching attributes like <code>th:text</code>, <code>th:if</code> or <code>th:whatever</code> (or <code>data-th-text</code>, <code>data-th-if</code> and <code>data-th-whatever</code> if we prefer <em>pure HTML5</em> syntax). Note however that the prefix returned here by a dialect is <strong>only the default one</strong> to be used for that dialect, but such prefix can be changed during template engine configuration. Also note that prefix can be <code>null</code> if we want our processors to execute on unprefixed tags/attributes.</p></li><li><p>The <em>dialect precedence</em> allows the sorting of processors across dialects. Processors define their own <em>precedence</em> value, but these processor precedences are considered <em>relative to dialect precedence</em>, so every processor in a specific dialect can be configured to be executed before all processors from a different dialect just by setting the correct values for this <em>dialect precedence</em>.</p></li><li><p>The <em>processors</em> are, as its name implies, the set of <em>processors</em> provided by the dialect. Note the <code>getProcessors(...)</code> method is passed the <code>dialectPrefix</code> as an argument in case the dialect has been configured at the Template Engine with a prefix different to the default one. Most probably the <code>IProcessor</code> instances will need this information during their initialization.</p></li></ul></section><section id="pre-processor-dialects-ipreprocessordialect" class="level3"><h3>Pre-processor dialects: <code>IPreProcessorDialect</code></h3><p><strong>Pre-processors</strong> and <strong>post-processors</strong> are different to <em>processors</em> in that instead of executing on a single event or on an event model (a fragment of a template), they apply to the entire template execution process as an additional step in the engine’s processing chain. Therefore they follow an API completely different to that of processors, much more event-oriented, defined by the lower-level <code>ITemplateHandler</code> interface.</p><p>In the specific case of the pre-processors, they apply <strong>before</strong> the Thymeleaf engine starts executing processors for a specific template.</p><p>The <code>IPreProcessorDialect</code> interface looks like:</p><pre class="java"><code>public interface IPreProcessorDialect extends IDialect {

    public int getDialectPreProcessorPrecedence();
    public Set&lt;IPreProcessor&gt; getPreProcessors();

}</code></pre><p>Which is very similar to the <code>IProcessorDialect</code> above –including its own dialect-level precedence for pre-processors– but lacks a <em>prefix</em>, as pre-processors don’t need it at all (they don’t <em>match</em> on specific events – instead they handle all of them).</p></section><section id="post-processor-dialects-ipostprocessordialect" class="level3"><h3>Post-processor dialects: <code>IPostProcessorDialect</code></h3><p>As stated above, <strong>post-processors</strong> are an additional step in the template execution chain, but this time they execute <strong>after</strong> the Thymeleaf engine has applied all the needed processors. This means post-processors apply just before template output happens (and can therefore modify what is being output).</p><p>The <code>IPostProcessorDialect</code> interface looks like:</p><pre class="java"><code>public interface IPostProcessorDialect extends IDialect {

    public int getDialectPostProcessorPrecedence();
    public Set&lt;IPostProcessor&gt; getPostProcessors();

}</code></pre><p>…which is completely analogous to the <code>IPreProcessorDialect</code> interface, but of course for post-processors in this case.</p></section><section id="expression-object-dialects-iexpressionobjectdialect" class="level3"><h3>Expression Object dialects: <code>IExpressionObjectDialect</code></h3><p>Dialects implementing this interface provide new <em>expression objects</em> or <em>expression utility objects</em> that can be used in expressions anywhere in templates, such as the <code>#strings</code>, <code>#numbers</code>, <code>#dates</code>, etc. provided by the Standard Dialect.</p><p>The <code>IExpressionObjectDialect</code> interface looks like this:</p><pre class="java"><code>public interface IExpressionObjectDialect extends IDialect {

    public IExpressionObjectFactory getExpressionObjectFactory();

}</code></pre><p>Which, as we can see, does not return the expression objects themselves, but only a <em>factory</em>. The reason for this is some <em>expression objects</em> might require data from the processing context in order to being built, so it won’t be possible to build them until we really are processing the template… and besides, most expressions don’t need <em>expression objects</em> at all, so it’s just better to build them <em>on demand</em>, only when they are really needed for specific expressions (and build only those that are needed).</p><p>This is the <code>IExpressionObjectFactory</code> interface:</p><pre class="java"><code>public interface IExpressionObjectFactory {

    public Map&lt;String,ExpressionObjectDefinition&gt; getObjectDefinitions();

    public Object buildObject(final IProcessingContext processingContext, final String expressionObjectName);

}</code></pre></section><section id="execution-attribute-dialects-iexecutionattributedialect" class="level3"><h3>Execution Attribute dialects: <code>IExecutionAttributeDialect</code></h3><p>Dialects implementing this interface are allowed to provide <em>execution attributes</em>, i.e. objects that are available to every processor being executed during template processing.</p><p>For example, the Standard Dialect implements this interface in order to provide to every processor:</p><ul><li>The <em>Thymeleaf Standard Expression parser</em> so that Standard Expressions in any attribute can be parsed and executed.</li><li>The <em>Variable Expression Evaluator</em> so that <code>${...}</code> expressions are executed either in OGNL or SpringEL (depending on whether we are using the Spring integration module or not).</li><li>The <em>Conversion Service</em> that performs conversion operations in <code>${{...}}</code> expressions.</li></ul><p>Note that these objects are not available at the context, so they cannot be used from template expressions. Their availability is limited to implementations of extension points such as processors, pre-processors, etc.</p><p>The <code>IExecutionAttributeDialect</code> interface is very simple:</p><pre class="java"><code>public interface IExecutionAttributeDialect extends IDialect {

    public Map&lt;String,Object&gt; getExecutionAttributes();

}</code></pre></section></section><section id="processors" class="level2"><h2>2.2. Processors</h2><p>Processors are objects implementing the <code>org.thymeleaf.processor.IProcessor</code> interface, and they contain the real logic to be applied on the different parts of a template (which we will represent as <strong>events</strong>, given Thymeleaf is an event-based engine). This interface looks like this:</p><pre class="java"><code>public interface IProcessor {

    public TemplateMode getTemplateMode();
    public int getPrecedence();

}</code></pre><p>As with dialects, this is a very simple interface that only specified the template mode in which the processor can be applied and its precedence.</p><p>But there are several types of <em>processor</em>, one for each possible type of event:</p><ul><li>Template start/end</li><li>Element Tags</li><li>Texts</li><li>Comments</li><li>CDATA Sections</li><li>DOCTYPE Clauses</li><li>XML Declarations</li><li>Processing Instructions</li></ul><p>And also for <strong>models</strong>: sequences of events representing an <em>entire element</em>, i.e.  an element with its entire body, including any nested elements or any other kind of artifacts that might appear inside. If the modelled element is a <em>standalone element</em>, the model will only contain its corresponding event; but if the modelled element has a body, the model will contain every event from its <em>open tag</em> to its <em>close tag</em>, both included.</p><p>All these types of processors are created by implementing a specific interface, or by extending one of the available <em>abstract implementations</em>. All these artifacts conforming the Thymeleaf Processor API live at the <code>org.thymeleaf.processor</code> package.</p><section id="element-processors" class="level3"><h3>Element Processors</h3><p>Element processors are those that are executed on the <em>open element</em> (<code>IOpenElementTag</code>) or <em>standalone element</em> (<code>IStandaloneElementTag</code>) events, normally by means of matching the name of the element (and/or one of its attributes) with a matching configuration specified by the processor. This is what the <code>IElementProcessor</code> interface looks like:</p><pre class="java"><code>public interface IElementProcessor extends IProcessor {

    public MatchingElementName getMatchingElementName();
    public MatchingAttributeName getMatchingAttributeName();

}</code></pre><p>Note however that element processor implementations are not meant to directly implement this interface. Instead, element processors should fall into one of two categories:</p><ul><li><strong>Element Tag Processors</strong>, implementing the <code>IElementTagProcessor</code> interface. These processors execute on <em>open/standalone tag events only</em> (no processors can be applied to <em>close tags</em>), and have no direct access to the element body.</li><li><strong>Element Model Processors</strong>, implementing the <code>IElementModelProcessor</code> interface. These processors execute on <em>complete elements</em>, including their bodies, in the form of <code>IModel</code> objects.</li></ul><p>We should have a look at each of these interfaces separately:</p></section><section id="element-tag-processors-ielementtagprocessor" class="level3"><h3>Element Tag Processors: <code>IElementTagProcessor</code></h3><p>Element Tag Processors, as explained, execute on the single <em>open element</em> or <em>standalone element</em> tag that matches its matching configuration (seen in <code>IElementProcessor</code>). The interface to be implemented is <code>IElementTagProcessor</code>, which looks like this:</p><pre class="java"><code>public interface IElementTagProcessor extends IElementProcessor {

    public void process(
            final ITemplateContext context, 
            final IProcessableElementTag tag,
            final IElementTagStructureHandler structureHandler);

}</code></pre><p>As we can see, besides extending <code>IElementProcessor</code> it only specifies a <code>process(...)</code> method that will be executed when the <em>matching configuration</em> matches (and in the order established by its <em>precedence</em>, established at the <code>IProcessor</code> superinterface). The <code>process(...)</code> signature is quite compact, and follows a pattern found in every Thymeleaf processor interface:</p><ul><li>The <code>process(...)</code> method returns <code>void</code>. Any actions will be performed via the <code>structureHandler</code>.</li><li>The <code>context</code> argument contains the context with which the template is being executed: variables, template data, etc.</li><li>The <code>tag</code> argument is the event on which the processor is being fired. It contains both the name of the element and its attributes.</li><li>The <code>structureHandler</code> is a special object that allows the processor to give instructions to the engine about actions that it should perform as a consequence of the execution of the processor.</li></ul><p><strong>Using the <code>structureHandler</code></strong></p><p>The <code>tag</code> argument passed to <code>process(...)</code> is an <strong>immutable</strong> object. So there is no way to, for example, directly modify the attributes of a tag on the <code>tag</code> object itself. Instead, the <code>structureHandler</code> should be used.</p><p>For example, let’s see how we would read the value of a specific <code>tag</code> attribute, unescape it and keep it in a variable, and then remove the attribute from the tag:</p><pre class="java"><code>// Obtain the attribute value
String attributeValue = tag.getAttributeValue(attributeName);

// Unescape the attribute value
attributeValue = 
    EscapedAttributeUtils.unescapeAttribute(context.getTemplateMode(), attributeValue);

// Instruct the structureHandler to remove the attribute from the tag
structureHandler.removeAttribute(attributeName);

... // do something with that attributeValue</code></pre><p><em>Note that the code above is only meant to showcase some attribute management concepts – in most processors we won’t need to do this “get value + unescape + remove” operation manually as it will all be handled by an extended superclass such as <code>AbstractAttributeTagProcessor</code></em>.</p><p>Above we’ve seen only one of the <em>operations</em> offered by the <code>structureHandler</code>. There is a <em>structure handler</em> for each type of processor in Thymeleaf, and the one for <em>element tag</em> processors implements the <code>IElementTagStructureHandler</code> interface, which looks like this:</p><pre class="java"><code>public interface IElementTagStructureHandler {

    public void reset();

    public void setLocalVariable(final String name, final Object value);
    public void removeLocalVariable(final String name);

    public void setAttribute(final String attributeName, final String attributeValue);
    public void setAttribute(final String attributeName, final String attributeValue, 
                             final AttributeValueQuotes attributeValueQuotes);

    public void replaceAttribute(final AttributeName oldAttributeName, 
                                 final String attributeName, final String attributeValue);
    public void replaceAttribute(final AttributeName oldAttributeName, 
                                 final String attributeName, final String attributeValue, 
                                 final AttributeValueQuotes attributeValueQuotes);

    public void removeAttribute(final String attributeName);
    public void removeAttribute(final String prefix, final String name);
    public void removeAttribute(final AttributeName attributeName);

    public void setSelectionTarget(final Object selectionTarget);

    public void setInliner(final IInliner inliner);

    public void setTemplateData(final TemplateData templateData);

    public void setBody(final String text, final boolean processable);
    public void setBody(final IModel model, final boolean processable);

    public void insertBefore(final IModel model); // cannot be processable
    public void insertImmediatelyAfter(final IModel model, final boolean processable);

    public void replaceWith(final String text, final boolean processable);
    public void replaceWith(final IModel model, final boolean processable);


    public void removeElement();
    public void removeTags();
    public void removeBody();
    public void removeAllButFirstChild();

    public void iterateElement(final String iterVariableName, 
                               final String iterStatusVariableName, 
                               final Object iteratedObject);

}</code></pre><p>There we can see all the actions that a processor can ask the template engine to do as a result of its execution. The method names are quite self-explanatory (and there is javadoc for them), but very briefly:</p><ul><li><code>setLocalVariable(...)</code>/<code>removeLocalVariable(...)</code> will add a local variable to the template execution. This <em>local variable</em> will be accessible during the rest of the execution of the current event, and also during all its <em>body</em> (i.e. until its corresponding <em>close tag</em>)</li><li><code>setAttribute(...)</code> adds a new attribute to the tag with a specified value (and maybe also type of surrounding quotes). If the attribute already exists, its value will be replaced.</li><li><code>replaceAttribute(...)</code> replaces an existing attribute with a new one, taking its place in the attribute (including its surrounding white space, for example).</li><li><code>removeAttribute(...)</code> removes an attribute from the tag.</li><li><code>setSelectionTarget(...)</code> modifies the object that is to be considered the <em>selection target</em>, i.e. the object on which <em>selection expressions</em> (<code>*{...}</code>) will be executed. In the Standard Dialect, this <em>selection target</em> is usually modified by means of the <code>th:object</code> attribute, but custom processors can do it too. Note the <em>selection target</em> has the same scope as a local variable, and will therefore be accessible only inside the body of the element being processed.</li><li><code>setInliner(...)</code> modifies the <em>inliner</em> to be used for processing all text nodes (<code>IText</code> events) appearing in the body of the element being processed. This is the mechanism used by the <code>th:inline</code> attribute to enable <em>inlining</em> in any of the specified modes (<code>text</code>, <code>javascript</code>, etc).</li><li><code>setTemplateData(...)</code> modifies the metadata about the template that is actually being processed. When inserting fragments, this allows the engine to know data about the specific fragment being processed, and also the complete stack of fragments being nested.</li><li><code>setBody(...)</code> replaces all the body of the element being processed with the passed text or model (sequence of events = fragment of markup). This is the way e.g. that <code>th:text</code>/<code>th:utext</code> work. Note that the specified replacement text or model can be set as <em>processable</em> or not, depending on whether we want to execute any processors that might be associated with them. In the case of <code>th:utext="${var}"</code>, for example, the replacement is set as <em>non-processable</em> in order to avoid executing any markup that might be returned by <code>${var}</code> as a part of the template.</li><li><code>insertBefore(...)</code>/<code>insertImmediatelyAfter(...)</code> allow the specification of a model (fragment of markup) that should appear before or <em>immediately</em> after the tag being processed. Note that <code>insertImmediatelyAfter</code> means <em>after the tag being processed</em> (and therefore as the first part of the element’s body) and not <em>after the entire element that opens here, and closes in a close tag somewhere</em>.</li><li><code>replaceWith(...)</code> allows the current <em>element</em> (entire element) to be replaced with the text or model specified as argument.</li><li><code>removeElement()</code>/<code>removeTags()</code>/<code>removeBody()</code>/<code>removeAllButFirstChild()</code> allow the processor to remove, respectively, the entire element including its body, only the executed tags (open + close) but not the body, only the body but not the wrapping tags, and lastly all the tag’s children except the first child element. Note all these options basically mirror the different values that can be used at the <code>th:remove</code> attribute.</li><li><code>iterateElement(...)</code> allows the current element (body included) to be iterated as many times as elements exist in the <code>iteratedObject</code> (which will usually be a <code>Collection</code>, <code>Map</code>, <code>Iterator</code> or an array). The other two arguments will be used for specifying the names of the variables used for the iterated elements and the status variable.</li></ul><p><strong>Abstract implementations for <code>IElementTagProcessor</code></strong></p><p>Thymeleaf offers two basic implementations of <code>IElementTagProcessor</code> that processors might implement for convenience:</p><ul><li><code>org.thymeleaf.processor.element.AbstractElementTagProcessor</code>, meant for processors that match element events by their element name (i.e. without looking at attributes).</li><li><code>org.thymeleaf.processor.element.AbstractAttributeTagProcessor</code>, meant for processors that match element events by one of their attributes (and optionally also the element name).</li></ul></section><section id="element-model-processors-ielementmodelprocessor" class="level3"><h3>Element Model Processors: <code>IElementModelProcessor</code></h3><p>Element Model Processors execute on the entire elements they match –including their bodies– in the form of an <code>IModel</code> object that contains the complete sequence of events that models such element and its contents. The <code>IElementModelProcessor</code> is very similar to the one seen above for <em>tag processors</em>:</p><pre class="java"><code>public interface IElementModelProcessor extends IElementProcessor {

    public void process(
            final ITemplateContext context, 
            final IModel model,
            final IElementModelStructureHandler structureHandler);

}</code></pre><p>Note how this interface also extends <code>IElementProcessor</code>, and how the <code>process(...)</code> method it contains follows the same structure as the one in tag processors, replacing <code>tag</code> with <code>model</code> of course:</p><ul><li><code>process(...)</code> returns <code>void</code>. Actions will be performed on <code>model</code> or <code>structureHandler</code>, not by returning anything.</li><li><code>context</code> contains the execution context: variables, etc.</li><li><code>model</code> is the sequence of events modelling the entire element on which the processor is being executed. This model can be directly modified from the processor.</li><li><code>structureHandler</code> allows instructing the engine to perform actions beyond model modification (e.g. setting local variables).</li></ul><p><strong>Reading and modifying the model</strong></p><p>The <code>IModel</code> object passed as a parameter to the <code>process()</code> method is a <strong>mutable</strong> model, so it allows any modifications to be done on it (<em>models</em> are mutable, <em>events</em> such as <em>tags</em> are immutable). For example, we might want to modify it so that we replace every text node from its body with a comment with the same contents:</p><pre class="java"><code>final IModelFactory modelFactory =  context.getModelFactory();

int n = model.size();
while (n-- != 0) {
    final ITemplateEvent event = model.get(n);
    if (event instanceof IText) {
        final IComment comment =
                modelFactory.createComment(((IText)event).getText());
        model.insert(n, comment);
        model.remove(n + 1);
    }
}</code></pre><p>Note also that the <code>IModel</code> interface includes an <code>accept(IModelVisitor visitor)</code> method, useful for traversing an entire model looking for specific nodes or relevant data using the <em>Visitor</em> pattern.</p><p><strong>Using the <code>structureHandler</code></strong></p><p>Similarly to <em>tag processors</em>, model processors are passed a <em>structure handler</em> object that allows them to instruct the engine to take any actions that cannot be done by directly acting on the <code>IModel model</code> object itself. The interface these structure handlers implement, much smaller than the one for tag processors, is <code>IElementModelStructureHandler</code>:</p><pre class="java"><code>public interface IElementModelStructureHandler {

    public void reset();

    public void setLocalVariable(final String name, final Object value);
    public void removeLocalVariable(final String name);

    public void setSelectionTarget(final Object selectionTarget);

    public void setInliner(final IInliner inliner);

    public void setTemplateData(final TemplateData templateData);

}</code></pre><p>It’s easy to see this is a subset of the one for tag processors. The few methods there work the same way:</p><ul><li><code>setLocalVariable(...)</code>/<code>removeLocalVariable(...)</code> for adding/removing local variables that will be available during the model’s execution (after the current processor’s execution).</li><li><code>setSelectionTarget(...)</code> for modifying the <em>selection target</em> applied during the model’s execution.</li><li><code>setInliner(...)</code> for setting an inliner.</li><li><code>setTemplateData(...)</code> for setting metadata about the template being processed.</li></ul><p><strong>Abstract implementations for <code>IElementModelProcessor</code></strong></p><p>Thymeleaf offers two basic implementations of <code>IElementModelProcessor</code> that processors might implement for convenience:</p><ul><li><code>org.thymeleaf.processor.element.AbstractElementModelProcessor</code>, meant for processors that match element events by their element name (i.e. without looking at attributes).</li><li><code>org.thymeleaf.processor.element.AbstractAttributeModelProcessor</code>, meant for processors that match element events by one of their attributes (and optionally also the element name).</li></ul></section><section id="template-startend-processors-itemplateboundariesprocessor" class="level3"><h3>Template start/end Processors: <code>ITemplateBoundariesProcessor</code></h3><p>Template Boundaries Processors are a kind of processor that executes on the <em>template start</em> and <em>template end</em> events fired during template processing. They allow to perform any kind of initialization or disposal of resources at beginning or end of the template processing operation. Note that these events are <strong>only fired for the first-level template</strong>, and not for each of the fragments that might be parsed and/or included into the template being processed.</p><p>The <code>ITemplateBoundariesProcessor</code> interface looks like this:</p><pre class="java"><code>public interface ITemplateBoundariesProcessor extends IProcessor {

    public void processTemplateStart(
            final ITemplateContext context,
            final ITemplateStart templateStart,
            final ITemplateBoundariesStructureHandler structureHandler);

    public void processTemplateEnd(
            final ITemplateContext context,
            final ITemplateEnd templateEnd,
            final ITemplateBoundariesStructureHandler structureHandler);

}</code></pre><p>This time the interface offers two <code>process*(...)</code> methods, one for the <em>template start</em> and another one for the <em>template end</em> events. Their signature follows the same pattern as the other <code>process(...)</code> methods we saw before, receiving the context, the event object, and the structure handler. Structure handler that, in this case, implements a quite simple <code>ITemplateBoundariesStructureHandler</code> interface:</p><pre class="java"><code>public interface ITemplateBoundariesStructureHandler {

    public void reset();

    public void setLocalVariable(final String name, final Object value);
    public void removeLocalVariable(final String name);

    public void setSelectionTarget(final Object selectionTarget);

    public void setInliner(final IInliner inliner);

    public void insert(final String text, final boolean processable);
    public void insert(final IModel model, final boolean processable);

}</code></pre><p>We can see how, besides the usual methods for managing local variables, selection target and inliner, we can also use the structure handler for inserting text or a model, which in this case will appear at the very beginning or the very end of the result (depending on the event being processed).</p></section><section id="other-processors" class="level3"><h3>Other processors</h3><p>There are other events for which Thymeleaf 3.0 allows processors to be declared, each of them implementing their corresponding interface:</p><ul><li><strong>Text</strong> events: interface <code>ITextProcessor</code></li><li><strong>Comment</strong> events: interface <code>ICommentProcessor</code></li><li><strong>CDATA Section</strong> events: interface <code>ICDATASectionProcessor</code></li><li><strong>DOCTYPE Clause</strong> events: interface <code>IDocTypeProcessor</code></li><li><strong>XML Declaration</strong> events: interface <code>IXMLDeclarationProcessor</code></li><li><strong>Processing Instruction</strong> events: interface <code>IProcessingInstructionProcessor</code></li></ul><p>All of them look pretty much like this (which is the one for text events):</p><pre class="java"><code>public interface ITextProcessor extends IProcessor {

    public void process(
            final ITemplateContext context, 
            final IText text,
            final ITextStructureHandler structureHandler);

}</code></pre><p>Same pattern as all other <code>process(...)</code> methods: context, event, structure handler. And these structure handlers are very simple, just like this (again, the one for text events):</p><pre class="java"><code>public interface ITextStructureHandler {

    public void reset();

    public void setText(final CharSequence text);

    public void replaceWith(final IModel model, final boolean processable);

    public void removeText();

}</code></pre></section></section></section><section id="creating-our-own-dialect" class="level1"><h1>3 Creating our own Dialect</h1><p>The source code for the examples shown in this and future chapters of this guide can be found in the <em>extraThyme</em> example application:</p><ul><li><a href="https://github.com/thymeleaf/thymeleaf/tree/3.1-master/examples/spring5/thymeleaf-examples-spring5-extrathyme">Spring 5 extraThyme</a>.</li><li><a href="https://github.com/thymeleaf/thymeleaf/tree/3.1-master/examples/spring6/thymeleaf-examples-spring6-extrathyme">Spring 6 extraThyme</a>.</li></ul><section id="extrathyme-a-website-for-thymelands-football-league" class="level2"><h2>3.1. extraThyme: a website for Thymeland’s football league</h2><p>Football is a popular sport in Thymeland<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. There is a 10-team league going on there each season, and its organizers have just asked us to create a website for it called “extraThyme”.</p><p>This website will be very simple: just a table with:</p><ul><li>The team names.</li><li>How many matches they won, drew or lost, as well as the total points earned.</li><li>A remark explaining whether their position in the table qualifies them for higher-level competitions next year or else mean their relegation to regional leagues.</li></ul><p>Above the league table, a banner will be displaying headlines with the results of recent matches, and also there will be a clearly visible banner that warns users every Sunday that Sundays are match days, and therefore they should be going to the stadium instead of browsing the internet.</p><figure><img src="images/extendingthymeleaf/extrathyme-league-table.png" alt="extraThyme league table" /><figcaption>extraThyme league table</figcaption></figure><p>We will use HTML5, Spring MVC and the SpringStandard dialect for our application, and we will be extending Thymeleaf by creating a <code>score</code> dialect that includes:</p><ul><li>A <code>score:remarkforposition</code> attribute that outputs internationalized text for the Remarks column in the table. This text should explain whether the team’s position in the table qualifies it for the World Champions League, the Continental Play-Offs, or relegates it to the Regional League.</li><li>A <code>score:classforposition</code> attribute that establishes a CSS class for the table rows depending on the team’s remarks: blue background for the World Champions League, green for the Continental Play-Offs, and red for relegation.</li><li>A <code>score:headlines</code> tag for drawing the yellow box at the top with the results of recent matches. This tag should support an order attribute with values random (for showing a randomly selected match) and <code>latest</code> (default, for showing only the last match).</li><li>A <code>score:match-day-today</code> attribute that can be added to the league table header in order to (conditionally, if it is Sunday) add a banner warning the user that today is a match day.</li></ul><p>Our markup will therefore look like this, making use of both <code>th</code> and <code>score</code> attributes:</p><pre class="html"><code>&lt;!DOCTYPE html&gt;

&lt;!--/* Note the xmlns:* here are completely optional and only meant to     */--&gt;
&lt;!--/* avoid IDEs from complaining about tags/attributes they may not know */--&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:score=&quot;http://thymeleafexamples&quot;&gt;

  &lt;head&gt;
    &lt;title&gt;extraThyme: Thymeland&#39;s football website&lt;/title&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;
          href=&quot;../../css/extrathyme.css&quot; th:href=&quot;@{/css/extrathyme.css}&quot;/&gt;
  &lt;/head&gt;

  &lt;body&gt;

    &lt;div&gt;
      &lt;img src=&quot;../../images/extrathymelogo.png&quot; 
           alt=&quot;extraThyme logo&quot; title=&quot;extraThyme logo&quot;
           th:src=&quot;@{/images/extrathymelogo.png}&quot; th:alt-title=&quot;#{title.application}&quot;/&gt;
    &lt;/div&gt;

    &lt;score:headlines order=&quot;random&quot; /&gt;

    &lt;div class=&quot;leaguetable&quot;&gt;

      &lt;h2 score:match-day-today th:text=&quot;#{title.leaguetable(${execInfo.now.time})}&quot;&gt;
        League table for 07 July 2011
      &lt;/h2&gt;
      
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th th:text=&quot;#{team.name}&quot;&gt;Team&lt;/th&gt;
            &lt;th th:text=&quot;#{team.won}&quot; class=&quot;matches&quot;&gt;Won&lt;/th&gt;
            &lt;th th:text=&quot;#{team.drawn}&quot; class=&quot;matches&quot;&gt;Drawn&lt;/th&gt;
            &lt;th th:text=&quot;#{team.lost}&quot; class=&quot;matches&quot;&gt;Lost&lt;/th&gt;
            &lt;th th:text=&quot;#{team.points}&quot; class=&quot;points&quot;&gt;Points&lt;/th&gt;
            &lt;th th:text=&quot;#{team.remarks}&quot;&gt;Remarks&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr th:each=&quot;t : ${teams}&quot; score:classforposition=&quot;${tStat.count}&quot;&gt;
            &lt;td th:text=&quot;|${t.name} (${t.code})|&quot;&gt;The Winners (TWN)&lt;/td&gt;
            &lt;td th:text=&quot;${t.won}&quot; class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${t.drawn}&quot; class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td th:text=&quot;${t.lost}&quot; class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td th:text=&quot;${t.points}&quot; class=&quot;points&quot;&gt;3&lt;/td&gt;
            &lt;td score:remarkforposition=&quot;${tStat.count}&quot;&gt;Great winner!&lt;/td&gt;
          &lt;/tr&gt;
          &lt;!--/*--&gt;
          &lt;tr&gt;
            &lt;td&gt;The First Losers (TFL)&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;points&quot;&gt;1&lt;/td&gt;
            &lt;td&gt;Little loser!&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;The Last Losers (TLL)&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;0&lt;/td&gt;
            &lt;td class=&quot;matches&quot;&gt;1&lt;/td&gt;
            &lt;td class=&quot;points&quot;&gt;0&lt;/td&gt;
            &lt;td&gt;Big loooooser&lt;/td&gt;
          &lt;/tr&gt;
          &lt;!--*/--&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;

    &lt;/div&gt;

  &lt;/body&gt;

&lt;/html&gt;</code></pre><p><em>(Note that we’ve added a second and third rows to our table, surrounded by parser-level comments <code>&lt;!--/* ... */--&gt;</code> so that our template shows nicely as a prototype when directly opened in a browser.)</em></p></section><section id="changing-the-css-class-by-team-position" class="level2"><h2>3.2. Changing the CSS class by team position</h2><p>The first attribute processor we will develop will be <code>ClassForPositionAttributeTagProcessor</code>, which we will implement as a subclass of a convenience abstract class provided by Thymeleaf called <code>AbstractAttributeTagProcessor</code>.</p><p>This abstract class is the base for all tag processors (i.e. processors that act on <em>tag</em> events and not <em>models</em>) which match (i.e. are selected for execution) based on the existence of a specific attribute in such tag. In this case, <code>score:classforposition</code>.</p><p>The idea is that we will use this processor for setting a new value to the <code>class</code> attribute of the tag <code>score:classforposition</code> is living in.</p><p>Let’s have a look at our code:</p><pre class="java"><code>public class ClassForPositionAttributeTagProcessor extends AbstractAttributeTagProcessor {

    private static final String ATTR_NAME = &quot;classforposition&quot;;
    private static final int PRECEDENCE = 10000;


    public ClassForPositionAttributeTagProcessor(final String dialectPrefix) {
        super(
            TemplateMode.HTML, // This processor will apply only to HTML mode
            dialectPrefix,     // Prefix to be applied to name for matching
            null,              // No tag name: match any tag name
            false,             // No prefix to be applied to tag name
            ATTR_NAME,         // Name of the attribute that will be matched
            true,              // Apply dialect prefix to attribute name
            PRECEDENCE,        // Precedence (inside dialect&#39;s own precedence)
            true);             // Remove the matched attribute afterwards
    }


    @Override
    protected void doProcess(
            final ITemplateContext context, final IProcessableElementTag tag,
            final AttributeName attributeName, final String attributeValue,
            final IElementTagStructureHandler structureHandler) {

        final IEngineConfiguration configuration = context.getConfiguration();

        /*
         * Obtain the Thymeleaf Standard Expression parser
         */
        final IStandardExpressionParser parser =
                StandardExpressions.getExpressionParser(configuration);

        /*
         * Parse the attribute value as a Thymeleaf Standard Expression
         */
        final IStandardExpression expression = parser.parseExpression(context, attributeValue);

        /*
         * Execute the expression just parsed
         */
        final Integer position = (Integer) expression.execute(context);

        /*
         * Obtain the remark corresponding to this position in the league table.
         */
        final Remark remark = RemarkUtil.getRemarkForPosition(position);

        /*
         * Select the adequate CSS class for the element.
         */
        final String newValue;
        if (remark == Remark.WORLD_CHAMPIONS_LEAGUE) {
            newValue = &quot;wcl&quot;;
        } else if (remark == Remark.CONTINENTAL_PLAYOFFS) {
            newValue = &quot;cpo&quot;;
        } else if (remark == Remark.RELEGATION) {
            newValue = &quot;rel&quot;;
        } else {
            newValue = null;
        }

        /*
         * Set the new value into the &#39;class&#39; attribute (maybe appending to an existing value)
         */
        if (newValue != null) {
            String currentClass = tag.getAttribute(&quot;class&quot;).getValue();
            if (currentClass != null) {
                structureHandler.setAttribute(&quot;class&quot;, currentClass + &quot; &quot; + newValue);
            } else {
                structureHandler.setAttribute(&quot;class&quot;, newValue);
            }
        }

    }

}</code></pre><p>The basic logic flow is easy to see and understand: get the value of the attribute, use it for computing what we need, and finally use the <code>structureHandler</code> to instruct the engine about the modifications needed as a result.</p><p>It is important to note that we are creating this attribute with the ability of executing expressions written in the Standard Syntax (used by both the <em>Standard</em> and the <em>SpringStandard</em> dialects). This is, the ability to be set values like <code>${var}</code>, <code>#{messageKey}</code>, conditionals, etc. See how we use this in our template:</p><pre class="html"><code>&lt;tr th:each=&quot;t : ${teams}&quot; score:classforposition=&quot;${tStat.count}&quot;&gt;</code></pre><p>In order to evaluate these expressions (also called <em>Thymeleaf Standard Expressions</em>) we need to first obtain the Standard Expression Parser, then parse the attribute value, and finally execute the parsed expresion:</p><pre class="java"><code>final IStandardExpressionParser parser =
        StandardExpressions.getExpressionParser(configuration);

final IStandardExpression expression = parser.parseExpression(context, attributeValue);

final Integer position = (Integer) expression.execute(context);</code></pre><p>It’s also interesting the way we use the <code>structureHandler</code> to add a new attribute to the host tag (remember the <code>tag</code> object is immutable):</p><pre class="java"><code>if (newValue != null) {
    String currentClass = tag.getAttribute(&quot;class&quot;).getValue();
    if (currentClass != null) {
        structureHandler.setAttribute(&quot;class&quot;, currentClass + &quot; &quot; + newValue);
    } else {
        structureHandler.setAttribute(&quot;class&quot;, newValue);
    }
}</code></pre><p>Last, note that <strong>HTML-escaping texts and attribute is our responsibility</strong>, but in this case we know all the possible values of the <code>newValue</code> variable and they require no escaping, so for the sake of simplicity we are skipping that operation.</p></section><section id="displaying-an-internationalized-remark" class="level2"><h2>3.3. Displaying an internationalized remark</h2><p>The next thing to do is creating an attribute processor able to display the remark text. This will be very similar to the <code>ClassForPositionAttrProcessor</code>, but with a couple of important differences:</p><ul><li>We will not be setting a value for an attribute in the host tag, but rather the text body (content) of the tag, in the same way a <code>th:text</code> attribute does.</li><li>We need to access the message externalization (internationalization) system from our code so that we can display the text corresponding to the selected locale.</li></ul><p>We will be using the same <code>AbstractAttributeTagProcessor</code> base class. And this will be our code:</p><pre class="java"><code>public class RemarkForPositionAttributeTagProcessor extends AbstractAttributeTagProcessor {

    private static final String ATTR_NAME = &quot;remarkforposition&quot;;
    private static final int PRECEDENCE = 12000;


    public RemarkForPositionAttributeTagProcessor(final String dialectPrefix) {
        super(
            TemplateMode.HTML, // This processor will apply only to HTML mode
            dialectPrefix,     // Prefix to be applied to name for matching
            null,              // No tag name: match any tag name
            false,             // No prefix to be applied to tag name
            ATTR_NAME,         // Name of the attribute that will be matched
            true,              // Apply dialect prefix to attribute name
            PRECEDENCE,        // Precedence (inside dialect&#39;s precedence)
            true);             // Remove the matched attribute afterwards
    }


    @Override
    protected void doProcess(
            final ITemplateContext context, final IProcessableElementTag tag,
            final AttributeName attributeName, final String attributeValue,
            final IElementTagStructureHandler structureHandler) {

        final IEngineConfiguration configuration = context.getConfiguration();

        /*
         * Obtain the Thymeleaf Standard Expression parser
         */
        final IStandardExpressionParser parser =
                StandardExpressions.getExpressionParser(configuration);

        /*
         * Parse the attribute value as a Thymeleaf Standard Expression
         */
        final IStandardExpression expression =
                parser.parseExpression(context, attributeValue);

        /*
         * Execute the expression just parsed
         */
        final Integer position = (Integer) expression.execute(context);

        /*
         * Obtain the remark corresponding to this position in the league table
         */
        final Remark remark = RemarkUtil.getRemarkForPosition(position);
        
        /*
         * If no remark is to be applied, just set an empty body to this tag
         */
        if (remark == null) {
            structureHandler.setBody(&quot;&quot;, false); // false == &#39;non-processable&#39;
            return;
        }
        
        /*
         * Message should be internationalized, so we ask the engine to resolve
         * the message &#39;remarks.{REMARK}&#39; (e.g. &#39;remarks.RELEGATION&#39;). No
         * parameters are needed for this message.
         *
         * Also, we will specify to &quot;use absent representation&quot; so that, if this
         * message entry didn&#39;t exist in our resource bundles, an absent-message
         * label will be shown.
         */
        final String i18nMessage =
                context.getMessage(
                        RemarkForPositionAttributeTagProcessor.class, 
                        &quot;remarks.&quot; + remark.toString(), 
                        new Object[0], 
                        true);

        /*
         * Set the computed message as the body of the tag, HTML-escaped and
         * non-processable (hence the &#39;false&#39; argument)
         */
        structureHandler.setBody(HtmlEscape.escapeHtml5(i18nMessage), false);
        
    }

}</code></pre><section id="accessing-i18n-messages" class="level3"><h3>Accessing i18n messages</h3><p>Note that we are accessing the message externalization system with:</p><pre class="java"><code>final String i18nMessage =
        context.getMessage(
                RemarkForPositionAttributeTagProcessor.class, 
                &quot;remarks.&quot; + remark.toString(), 
                new Object[0], 
                true);</code></pre><p>This will call the message resolution mechanism configured at the engine, passing not only the specific key we are interested on and its parameters (none, in this case), but also two other pieces of information:</p><ul><li>The <em>origin</em> to be assigned to the message: <code>RemarkForPositionAttributeTagProcessor.class</code></li><li>Whether an <em>absent message representation</em> should be used (<code>true</code>)</li></ul><p>Message resolution is an <strong>extension point</strong> in Thymeleaf (<code>IMessageResolver</code> interface), and therefore how these parameters are treated depends on the specific implementation being used. The default implementation in non-Spring-enabled applications (<code>StandardMessageResolver</code>) will do the following:</p><ul><li>First look for <code>.properties</code> files with the same name as the template file + the locale. So if the template is <code>/views/main.html</code> and locale is <code>gl_ES</code>, it will look for <code>/views/main_gl_ES.properties</code>, then <code>/views/main_gl.properties</code> and last <code>/views/main.properties</code>.</li><li>If not found, then use the <em>origin</em> class (which could have been specified <code>null</code>) and look for <code>.properties</code> files in classpath with the name of the class specified there (the processor’s own class): <code>classpath:org/thymeleaf/examples/spring6/extrathyme/dialects/score/RemarkForPositionAttributeTagProcessor_gl_ES.properties</code>, etc. This allows the <em>componentization</em> or processors and dialects with their whole set of i18n resource bundles in plain old <code>.jar</code> files.</li><li>If none of these are found, have a look at the <em>absent message representation</em> flag. If <code>false</code>, simply return <code>null</code>. If <code>true</code>, create some kind of text that will allow the developer or user to quickly identify the fact that an i18n resource is missing: <code>??remarks.rel_gl_ES??</code>.</li></ul><p><em>(Note that, in Spring-enabled applications, this message resolution mechanism will be replaced by default with Spring’s own, based on the <code>MessageSource</code> beans declared at the Spring Application Context.)</em></p></section><section id="html-escaping-content" class="level3"><h3>HTML-escaping content</h3><p>Also, in this processor we are performing the required HTML-escaping of the content we are setting by using the <code>HtmlEscape</code> class from the <a href="http://unbescape.org">Unbescape</a> library, used for this purpose throughout Thymeleaf:</p><pre class="java"><code>structureHandler.setBody(HtmlEscape.escapeHtml5(i18nMessage), false);</code></pre></section></section><section id="an-element-processor-for-our-headlines" class="level2"><h2>3.4. An element processor for our headlines</h2><p>The third processor we will write is an element (tag) processor. Note we call this an <em>element tag processor</em> in contrast with the two previous processors, which were <em>attribute tag processors</em>. The reason is, in this case we want our processor to match (i.e. to be selected for execution) based on the <strong>name of the tag</strong>, not on the name of one of its attributes.</p><p>This kind of tag processor has one advantage and also one disadvantage with respect to attribute tag processors:</p><ul><li>Advantage: elements can contain multiple attributes, and so your element processors can receive a richer and more complex set of configuration parameters.</li><li>Disadvantage: custom elements/tags are unknown to browsers, and so if you are developing a web application using custom tags you might have to sacrifice one of the most interesting features of Thymeleaf: the ability to statically display templates as prototypes (<em>natural templating</em>).</li></ul><p>This processor will extend <code>AbstractElementTagProcessor</code>, the base class to be used for tag processors that do not match on a specific attribute:</p><pre class="java"><code>public class HeadlinesElementTagProcessor extends AbstractElementTagProcessor {

    private static final String TAG_NAME = &quot;headlines&quot;;
    private static final int PRECEDENCE = 1000;


    private final Random rand = new Random(System.currentTimeMillis());


    public HeadlinesElementTagProcessor(final String dialectPrefix) {
        super(
            TemplateMode.HTML, // This processor will apply only to HTML mode
            dialectPrefix,     // Prefix to be applied to name for matching
            TAG_NAME,          // Tag name: match specifically this tag
            true,              // Apply dialect prefix to tag name
            null,              // No attribute name: will match by tag name
            false,             // No prefix to be applied to attribute name
            PRECEDENCE);       // Precedence (inside dialect&#39;s own precedence)
    }


    @Override
    protected void doProcess(
            final ITemplateContext context, final IProcessableElementTag tag,
            final IElementTagStructureHandler structureHandler) {

        /*
         * Obtain the Spring application context.
         */
        final ApplicationContext appCtx = SpringContextUtils.getApplicationContext(context);

        /*
         * Obtain the HeadlineRepository bean from the application context, and ask
         * it for the current list of headlines.
         */
        final HeadlineRepository headlineRepository = appCtx.getBean(HeadlineRepository.class);
        final List&lt;Headline&gt; headlines = headlineRepository.findAllHeadlines();

        /*
         * Read the &#39;order&#39; attribute from the tag. This optional attribute in our tag 
         * will allow us to determine whether we want to show a random headline or
         * only the latest one (&#39;latest&#39; is default).
         */
        final String order = tag.getAttributeValue(&quot;order&quot;);

        String headlineText = null;
        if (order != null &amp;&amp; order.trim().toLowerCase().equals(&quot;random&quot;)) {
            // Order is random 

            final int r = this.rand.nextInt(headlines.size());
            headlineText = headlines.get(r).getText();
            
        } else {
            // Order is &quot;latest&quot;, only the latest headline will be shown
            
            Collections.sort(headlines);
            headlineText = headlines.get(headlines.size() - 1).getText();
            
        }

        /*
         * Create the DOM structure that will be substituting our custom tag.
         * The headline will be shown inside a &#39;&lt;div&gt;&#39; tag, and so this must
         * be created first and then a Text node must be added to it.
         */
        final IModelFactory modelFactory = context.getModelFactory();

        final IModel model = modelFactory.createModel();

        model.add(modelFactory.createOpenElementTag(&quot;div&quot;, &quot;class&quot;, &quot;headlines&quot;));
        model.add(modelFactory.createText(HtmlEscape.escapeHtml5(headlineText)));
        model.add(modelFactory.createCloseElementTag(&quot;div&quot;));

        /*
         * Instruct the engine to replace this entire element with the specified model.
         */
        structureHandler.replaceWith(model, false);
        
    }

}</code></pre><p>The first interesting part of the code above is showing how to access Spring’s <code>ApplicationContext</code> in order to obtain one of our beans from it (the <code>HeadlineRepository</code>):</p><pre class="java"><code>final ApplicationContext appCtx = SpringContextUtils.getApplicationContext(context);</code></pre><p>Also, this processor is different to the previous ones in that we will need to <em>create markup</em> as a result of its execution: we are going to replace the original <code>&lt;score:headlines .../&gt;</code> tag with a <code>&lt;div&gt;...&lt;/div&gt;</code> fragment, so we will need to make use of the <strong>model factory</strong>.</p><section id="the-model-factory" class="level3"><h3>The Model Factory</h3><p>The model factory is a special object available to processors (and other structures such as pre-processors, post-processors, etc.) that can create new instances of <em>events</em> as <em>models</em> (fragments of templates), and also new instances of <em>models</em> themselves.</p><p>It is therefore the tool for creating new markup, like we can see in the code above:</p><pre class="java"><code>final IModelFactory modelFactory = context.getModelFactory();

final IModel model = modelFactory.createModel();

model.add(modelFactory.createOpenElementTag(&quot;div&quot;, &quot;class&quot;, &quot;headlines&quot;));
model.add(modelFactory.createText(HtmlEscape.escapeHtml5(headlineText)));
model.add(modelFactory.createCloseElementTag(&quot;div&quot;));</code></pre><p>Note how markup events needs to be created <em>one event at a time</em>, and how the open and close tags for the same <code>div</code> element have to be created separately and in the correct order. This is because models are <em>sequences of events</em> and not nodes in a Document Object Model (DOM).</p><p>The model factory offers a quite complete set of methods for creating all types of events: tags, texts, DOCTYPEs… and also useful methods for modifying the attributes in a tag (by creating a new <code>tag</code> instance, given they are immutable), such as:</p><pre class="java"><code>final IOpenElemenTag newTag = modelFactory.setAttribute(tag, &quot;class&quot;, &quot;newvalue&quot;);</code></pre><p>Also, the model factory is able to create <code>IModel</code> instances from scratch (like the <code>modelFactory.createModel()</code> above), from a single existing event, and also from a piece of markup that we want to convert into its corresponding sequence of events by <em>parsing</em> it:</p><pre class="java"><code>final IModel model = 
        modelFactory.parse(
                context.getTemplateData(), 
                &quot;&lt;div class=&#39;headlines&#39;&gt;Some headlines&lt;/div&gt;&quot;);</code></pre></section></section><section id="a-model-processor-for-our-match-day-today-banner" class="level2"><h2>3.5. A model processor for our “Match Day Today” banner</h2><p>The last processor we will include in our dialect is of a different nature than the ones we’ve seen so far: it is a <strong>model processor</strong>, not a <em>tag processor</em>.</p><p>As already mentioned in a previous section, model processors do not execute on a specific tag event, but on the complete sequence of events (i.e. the <em>model</em>) that contains the entire element they are matching.</p><p>So if we have a model processor that matches <code>&lt;p&gt;</code> tags with attribute <code>score:matcher</code>, and a fragment of template such as:</p><pre class="html"><code>&lt;p score:matcher=&quot;whatever&quot;&gt;
    This is some body
&lt;/p&gt;</code></pre><p>That <em>model processor</em> will receive as an argument of its <code>doProcess()</code> method an <code>IModel</code> containing 3 events: <code>&lt;p score:matcher="whatever"&gt;</code> (open tag), <code>\n    This is some body\n</code> (text) and <code>&lt;/p&gt;</code> (close tag).</p><p>So back to our requirements: we wanted a model processor matching a <code>scrore:match-day-today</code>, that we can apply to the league table header and make it display, below this header, a banner warning the user that sundays are match days:</p><pre class="html"><code>&lt;h2 score:match-day-today th:text=&quot;#{title.leaguetable(${execInfo.now.time})}&quot;&gt;
    League table for 07 July 2011
&lt;/h2&gt;</code></pre><p>Note that we don’t need a value for this <code>score:match-day-today</code> attribute, so we can just ignore it. Our code will like like this:</p><pre class="java"><code>public class MatchDayTodayModelProcessor extends AbstractAttributeModelProcessor {

    private static final String ATTR_NAME = &quot;match-day-today&quot;;
    private static final int PRECEDENCE = 100;


    public MatchDayTodayModelProcessor(final String dialectPrefix) {
        super(
            TemplateMode.HTML, // This processor will apply only to HTML mode
            dialectPrefix,     // Prefix to be applied to name for matching
            null,              // No tag name: match any tag name
            false,             // No prefix to be applied to tag name
            ATTR_NAME,         // Name of the attribute that will be matched
            true,              // Apply dialect prefix to attribute name
            PRECEDENCE,        // Precedence (inside dialect&#39;s own precedence)
            true);             // Remove the matched attribute afterwards
    }


    protected void doProcess(
            final ITemplateContext context, final IModel model,
            final AttributeName attributeName, final String attributeValue,
            final IElementModelStructureHandler structureHandler) {


        if (!checkPositionInMarkup(context)) {
            throw new TemplateProcessingException(
                    &quot;The &quot; + ATTR_NAME + &quot; attribute can only be used inside a &quot; +
                    &quot;markup element with class \&quot;leaguetable\&quot;&quot;);
        }

        final Calendar now = Calendar.getInstance(context.getLocale());
        final int dayOfWeek = now.get(Calendar.DAY_OF_WEEK);

        // Sundays are Match Days!!
        if (dayOfWeek == Calendar.SUNDAY) {

            // The Model Factory will allow us to create new events
            final IModelFactory modelFactory = context.getModelFactory();

            // We will be adding the &quot;Today is Match Day&quot; banner just after
            // the element we are processing for:
            //
            // &lt;h4 class=&quot;matchday&quot;&gt;Today is MATCH DAY!&lt;/h4&gt;
            //
            model.add(modelFactory.createOpenElementTag(&quot;h4&quot;, &quot;class&quot;, &quot;matchday&quot;)); //
            model.add(modelFactory.createText(&quot;Today is MATCH DAY!&quot;));
            model.add(modelFactory.createCloseElementTag(&quot;h4&quot;));

        }

    }


    private static boolean checkPositionInMarkup(final ITemplateContext context) {

        /*
         * We want to make sure this processor is being applied inside a container tag which has
         * class=&quot;leaguetable&quot;. So we need to check the second-to-last entry in the element stack
         * (the last entry is the tag being processed itself).
         */

        final List&lt;IProcessableElementTag&gt; elementStack = context.getElementStack();
        if (elementStack.size() &lt; 2) {
            return false;
        }

        final IProcessableElementTag container = elementStack.get(elementStack.size() - 2);
        if (!(container instanceof IOpenElementTag)) {
            return false;
        }

        final String classValue = container.getAttributeValue(&quot;class&quot;);
        return classValue != null &amp;&amp; classValue.equals(&quot;leaguetable&quot;);

    }


}</code></pre><p>The first thing to note is that we are performing a check on the position the attribute is being used at: we will only allow it inside a container with <code>class="leaguetable"</code>. So our <code>checkPositionInMarkup(...)</code> method makes use of the <em>element stack</em> in order to know the list of tags that had to be processed in order to process the current one.</p><p>Also, regarding the way the new banner element is created (an <code>&lt;h4&gt;</code>) notice how what we are doing is modifying the <code>model</code> attribute passed as an argument to <code>doProcess(...)</code>. No new model object is being created:</p><pre class="java"><code>final IModelFactory modelFactory = context.getModelFactory();

model.add(modelFactory.createOpenElementTag(&quot;h4&quot;, &quot;class&quot;, &quot;matchday&quot;)); //
model.add(modelFactory.createText(&quot;Today is MATCH DAY!&quot;));
model.add(modelFactory.createCloseElementTag(&quot;h4&quot;));</code></pre></section><section id="declaring-it-all-the-dialect" class="level2"><h2>3.6. Declaring it all: the Dialect</h2><p>The last step we need to take in order to complete our dialect is, of course, the dialect class itself.</p><p>As seen in a previous section, dialects might implement different interfaces depending on what they provide to the template engine. In this case, our dialect is only providing processors so it will be implementing <code>IProcessorDialect</code>.</p><p>In fact, we will extend an abstract convenience implementation that will ease the implementation of the interface: <code>AbstractProcessorDialect</code>:</p><pre class="java"><code>public class ScoreDialect extends AbstractProcessorDialect {

    private static final String DIALECT_NAME = &quot;Score Dialect&quot;;


    public ScoreDialect() {
        // We will set this dialect the same &quot;dialect processor&quot; precedence as
        // the Standard Dialect, so that processor executions can interleave.
        super(DIALECT_NAME, &quot;score&quot;, StandardDialect.PROCESSOR_PRECEDENCE);
    }

    /*
     * Two attribute processors are declared: &#39;classforposition&#39; and
     * &#39;remarkforposition&#39;. Also one element processor: the &#39;headlines&#39;
     * tag.
     */
    public Set&lt;IProcessor&gt; getProcessors(final String dialectPrefix) {
        final Set&lt;IProcessor&gt; processors = new HashSet&lt;IProcessor&gt;();
        processors.add(new ClassForPositionAttributeTagProcessor(dialectPrefix));
        processors.add(new RemarkForPositionAttributeTagProcessor(dialectPrefix));
        processors.add(new HeadlinesElementTagProcessor(dialectPrefix));
        processors.add(new MatchDayTodayModelProcessor(dialectPrefix));
        // This will remove the xmlns:score attributes we might add for IDE validation
        processors.add(new StandardXmlNsTagProcessor(TemplateMode.HTML, dialectPrefix));
        return processors;
    }


}</code></pre><p>Once our dialect is created, we will need to add it to our Template Engine object in order to use it. This being a Spring-enabled application, we will modify the declared template engine bean:</p><pre class="java"><code>@Bean
public SpringTemplateEngine templateEngine(){
    SpringTemplateEngine templateEngine = new SpringTemplateEngine();
    templateEngine.setTemplateResolver(templateResolver());
    templateEngine.addDialect(new ScoreDialect());
    return templateEngine;
}</code></pre><p>Note that the <code>addDialect(...)</code> call there will add the Score Dialect to the one already configured by default in a <code>SpringTemplateEngine</code>: the SpringStandard dialect.</p><p>And that’s it! Our dialect is ready to run now, and our league table will display in exactly the way we wanted.</p></section></section><section class="footnotes"><hr /><ol><li id="fn1"><p>European football, of course ;-)<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>
		</div>

	</div>

</body>

</html>
